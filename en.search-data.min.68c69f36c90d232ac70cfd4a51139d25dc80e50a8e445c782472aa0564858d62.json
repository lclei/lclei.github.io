[{"id":0,"href":"/about/","title":"About","section":"lclei blog","content":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n"},{"id":1,"href":"/post/epoll/","title":"epoll为什么比select高效","section":"Posts","content":"epoll介绍 #  epoll是linux继select和poll之后的多路IO复用方式。当监听的fd多了之后，select和poll都是要把所有的fd从头到尾遍历一遍，去查询是否有数据到达，这样非常低效。而epoll在内核中把监听的fd组织为红黑树，无疑提高了查找的效率。 在应用时，epoll的接口函数也很简单，只用了三个接口：\n1 2 3  epoll_create1 epoll_ctl epill_wait   自己写了一个dhcp客户端的仿真器，希望既接受终端的输入，也接收服务器的报文。使用epoll是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #define MAX_EVENTS 2 int main() { struct Client client = {0}; if (-1 == init_client(\u0026amp;client)) { log_error(\u0026#34;Init client error, exit.\u0026#34;); return -1; } struct epoll_event ev, events[MAX_EVENTS]; int epollfd = epoll_create1(0); if (epollfd == -1) { perror(\u0026#34;epoll_create1\u0026#34;); return -1; } ev.events = EPOLLIN | EPOLLET; ev.data.fd = client.sock; epoll_ctl(epollfd, EPOLL_CTL_ADD, client.sock, \u0026amp;ev); ev.data.fd = STDIN_FILENO; epoll_ctl(epollfd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev); while (true) { int nfds = epoll_wait(epollfd, events, MAX_EVENTS, 1); for (int i = 0; i \u0026lt; nfds; ++i) { process_event(events[i].data.fd, \u0026amp;client); } } return 0; }   和select用法其实是差不多的。事实上，在redis的源代码中，就把他们接口统一，作为ae使用，见ae_epoll.c，ae_select.c两个文件。 在linux内核中实现为/fs/epoll.c。关于epoll的实现原理以及为什么快，参考深入了解epoll模型，这篇文章写的比较详细，还有原理图示。  epoll内部使用红黑树组织监听的文件描述符，查找高效。 epoll使用共享内存减少文件描述符在用户态和内核之间的拷贝。  epoll水平触发和边沿触发 #  一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/epoll.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define println(fmt, args...) printf(fmt\u0026#34;\\n\u0026#34;, ##args) #define MAX_EVENTS 2  static void read_fd(int fd) { char buf[9] = {0}; int sz = read(fd, buf, sizeof(buf) - 1); println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf); } int main(int argc, char **argv) { println(\u0026#34;epoll_create\u0026#34;); int efd = epoll_create1(0); if (efd == -1) { perror(\u0026#34;epoll_create1\u0026#34;); exit(0); } struct epoll_event events[2], ev; set_nonblock(STDIN_FILENO); println(\u0026#34;epoll_ctl\u0026#34;); ev.events = EPOLLIN; ev.data.fd = STDIN_FILENO; epoll_ctl(efd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev); while (true) { println(\u0026#34;epoll_wait...\u0026#34;); int nfds = epoll_wait(efd, events, MAX_EVENTS, -1); if (nfds == -1) { perror(\u0026#34;epoll_wait\u0026#34;); return -1; } if (nfds \u0026gt; 0) { println(\u0026#34;epoll_wait return %d\u0026#34;, nfds); for (int i = 0; i \u0026lt; nfds; ++i) { read_fd(events[i].data.fd); } } } return 0; }   每次数据就绪后，只读8个字节，当输入123456789时： 水平触发：\n1 2 3 4 5 6 7 8 9 10 11  epoll_create epoll_ctl epoll_wait... 123456789 epoll_wait return 1 recv 8 bytes: 12345678 epoll_wait... epoll_wait return 1 recv 2 bytes: 9 epoll_wait...   边沿触发：\n1 2 3 4  println(\u0026#34;epoll_ctl\u0026#34;); ev.events = EPOLLIN | EPOLLET; ev.data.fd = STDIN_FILENO; epoll_ctl(efd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev);   其输出是\n1 2 3 4 5 6 7  epoll_create epoll_ctl epoll_wait... 123456789 epoll_wait return 1 recv 8 bytes: 12345678 epoll_wait...   只能读出8个字节。后面将不会自动触发，即使没有读完数据。因此需要自己保证读取数据完整，如使用EAGAIN判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static void read_fd(int fd) { // char buf[9] = {0};  // int sz = read(fd, buf, sizeof(buf) - 1);  // println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf);  while (true) { char buf[9] = {0}; int sz = read(fd, buf, sizeof(buf) - 1); if (sz == -1) { if (errno == EAGAIN) break; } println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf); } }   reference: 深入了解epoll模型 epoll边缘触发模式\n相关： [[muduo]] [[iouring]] [[select]]\n"},{"id":2,"href":"/post/fp_compare_cpp_rust/","title":"C++函数式编程与Rust对比","section":"Posts","content":"在刷leetcode的时候，想使用c++20的范围库，体验一下函数式编程的快乐。这一题是leetcode 300题。\n300. Longest Increasing Subsequence Given an integer array nums, return the length of the longest strictly increasing subsequence\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\nInput: nums = [0,1,0,3,2,3] Output: 4\nExample 3:\nInput: nums = [7,7,7,7,7,7,7] Output: 1\n有两种思路来做，现在用动态规划的方法实现： dp[i]是以nums[i]结尾的最长递增子序列的长度，注意必须是以nums[i]结尾，那么递归公式是\n1  dp[i] = max(dp[j]) + 1 if nums[i] \u0026gt; nums[j] and i \u0026gt; j   在c++中，为了获取索引，使用了C++23的enumerate。\n1 2 3 4 5 6 7 8  @startuml state dp dp -\u0026gt; dp1 : take i dp1 -\u0026gt; dp2 : enumerate dp2 -\u0026gt; dp3 : filter nums[i] \u0026gt; nums[j] dp3 -\u0026gt; dp4 : values dp4 -\u0026gt; max : max_element @enduml   code如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;ranges\u0026gt; using namespace std; class Solution300 { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sz = nums.size(); // dp: LIS size of end with nums[i]  vector\u0026lt;int\u0026gt; dp(sz, 0); dp[0] = 1; for (int i = 1; i \u0026lt; sz; ++i) { // views::enumerate and views::values need c++23  auto v = dp | views::take(i) | views::enumerate | views::filter([\u0026amp;](auto item) {return nums[get\u0026lt;0\u0026gt;(item)] \u0026lt; nums[i];}) | views::values; dp[i] = v.empty() ? 1 : *ranges::max_element(v) + 1; } return *ranges::max_element(dp); } };   其中对于max_element，本想直接写成\n1 2 3  dp[i] = *ranges::max_element(dp | views::take(i) | views::enumerate | views::filter([\u0026amp;](auto item) {return nums[get\u0026lt;0\u0026gt;(item)] \u0026lt; nums[i];}) | views::values) + 1;   然而有编译器报错\n1 2 3 4 5  error: no match for \u0026#39;operator*\u0026#39; (operand type is \u0026#39;std::ranges::borrowed_iterator_t\u0026lt;std::ranges::filter_view\u0026lt;std::ranges::take_view\u0026lt;std::ranges::ref_view\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; \u0026gt;, Solution300::lengthOfLIS(std::vector\u0026lt;int\u0026gt;\u0026amp;)::\u0026lt;lambda(int)\u0026gt; \u0026gt; \u0026gt;\u0026#39;) 70 | *ranges::max_element(dp | views::take(i) | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 71 | | views::filter([\u0026amp;](int x) {return x \u0026lt; nums[i];})); | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   错误显示该类型std::ranges::borrowed_iterator_t是不能解引用的。 从cppreference网站上查询像std::ranges::max_element， std::ranges::lower_bound这一类的算法返回的都是std::ranges::borrowed_iterator_t类型。\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt; ranges::range R \u0026gt; using borrowed_iterator_t = /* see below */; 若 R 实现 borrowed_range 则为 std::ranges::iterator_t\u0026lt;R\u0026gt; ，否则为 std::ranges::dangling 。 某些受约束算法用此二模板别名避免返回潜在悬垂的迭代器或视图。 template\u0026lt;class R\u0026gt; concept borrowed_range = ranges::range\u0026lt;R\u0026gt; \u0026amp;\u0026amp; (std::is_lvalue_reference_v\u0026lt;R\u0026gt; || ranges::enable_borrowed_range\u0026lt;std::remove_cvref_t\u0026lt;R\u0026gt;\u0026gt;); 概念 borrowed_range 定义范围的要求，使得函数能按值接收它，并返回从它获得的迭代器，而无悬垂之虞。   所以应该是生成的views类似于右值，其迭代器会悬垂失效，如果将它赋给左值，那么max_element返回的迭代器就可以使用了。\n1 2  auto v = ... dp[i] = v.empty() ? 1 : *ranges::max_element(v) + 1;   这里还有一个问题，max_element在Range为空时，返回的是rangs::begin(r)。想在一行写完，这点逻辑也不好表示。 因此C++的函数式编程在最后消费迭代器的时候，写法不是很便利。 在Rust中，相似的写法是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  implSolution{pubfn length_of_lis(nums: Vec\u0026lt;i32\u0026gt;)-\u0026gt; i32 {letsz=nums.len();letmutdp: Vec\u0026lt;i32\u0026gt;=vec![0;sz];for(i,n)innums.iter().enumerate(){dp[i]=*dp.iter().take(i).enumerate().filter(|(j,_)|nums[*j]\u0026lt;*n).map(|(_,v)|v).max().unwrap_or(\u0026amp;0)+1;}*dp.iter().max().unwrap();}}  Rust中迭代器的fp风格就比较自然，最后消费迭代器的max方法，也是能返回Option(T)，可以直接处理容器为空的情况了。 更进一步，如果不想两次循环dp的话，希望直接在第一次给dp赋值时，直接求出最大值，但是这样写显然会遭遇了闭包捕获不可变引用与已有可变引用冲突的问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  implSolution{pubfn length_of_lis(nums: Vec\u0026lt;i32\u0026gt;)-\u0026gt; i32 {letsz=nums.len();letmutdp: Vec\u0026lt;i32\u0026gt;=vec![0;sz];*dp.iter_mut().enumerate().map(|(i,v)|{*v=*dp.iter().take(i).enumerate().filter(|(j,_)|nums[*j]\u0026lt;nums[i]).map(|(_,v)|v).max().unwrap_or(\u0026amp;0)+1;v}).max().unwrap()}}  可见对这个问题，两个语言写法都挺奇怪的。但是Rust明显对函数式编程的支持更好。然而也可以看到现在的编程语言相互融合，越来越像。除了C。\n回到这个问题，还有另一种方法，新建一个subseq的vector。对于每个num，如果大于subseq最后的元素，则放入subseq。否则找到subseq中第一个大于等于num的位置，替换为num。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int max = 1; int sz = nums.size(); vector\u0026lt;int\u0026gt; subsq; for (int i = 0; i \u0026lt; sz; ++i) { if (subsq.empty() or nums[i] \u0026gt; subsq.back()) { subsq.push_back(nums[i]); } else { auto it = lower_bound(subsq.begin(), subsq.end(), nums[i]); if (it != subsq.end()) { *it = nums[i]; } } } return subsq.size(); } };   "},{"id":3,"href":"/post/flock/","title":"记一次文件锁死锁问题","section":"Posts","content":"flock是Linux系统提供的一个系统级的锁，可以用作进程间的同步，man 2 flock，显示其用法是\n1 2 3 4 5  NAME flock - apply or remove an advisory lock on an open file SYNOPSIS #include \u0026lt;sys/file.h\u0026gt; int flock(int fd, int operation);   operation可以取值：\n LOCK_SH 共享锁，读锁 LOCK_EX 互斥锁，写锁 LOCK_UN 解锁操作  另外一个参数fd是打开的文件描述符，所以文件锁与文件系统关系密切，其实现原理也是挂在打开的文件结构体上。因此当文件被关闭时，也会触发解锁操作。\n在shell中的用法是\n1  flock -x command arg # 互斥锁   本文记录一次死锁的问题，程序是多线程的，同时需要fork一个子进程去执行脚本。我们希望执行脚本与程序本身的函数调用互斥。于是在脚本中获取互斥锁，在函数执行前获取共享锁，从而达到互斥的目的。\n刚开始测试时运行良好，后来出现程序卡死的问题。下面来模拟一下当时的情况： demo.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  #include \u0026lt;pthread.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/file.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; #define println(fmt, args...) printf(fmt\u0026#34;\\n\u0026#34;, ##args) #define log(fmt, args...) println(\u0026#34;[p%u][t%lu]\u0026#34;fmt, getpid(), pthread_self(), ##args)  const char *lockpath = \u0026#34;./f.lock\u0026#34;; int flock_wrap(int fd, int op) { int ret = flock(fd, op); if (ret == -1) { perror(\u0026#34;flock error\u0026#34;); } return ret; } int flock_sh(int fd) { log(\u0026#34;flock sh, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_SH | LOCK_NB); } int flock_ex(int fd) { log(\u0026#34;flock ex, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_SH | LOCK_NB); } int unlock(int fd) { log(\u0026#34;flock unlock, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_UN); } typedef void *(*StartRoutine)(void *); pthread_t spawn(StartRoutine start, void *arg) { pthread_t tid; int ret = pthread_create(\u0026amp;tid, NULL, start, arg); if (ret == -1) { perror(\u0026#34;pthread create error\u0026#34;); return 0; } return tid; } void do_something() { log(\u0026#34;do some things...\u0026#34;); sleep(2); } void do_something_wrap() { int fd = open(lockpath, O_WRONLY | O_CREAT); log(\u0026#34;open %s as %d\u0026#34;, lockpath, fd); if (fd == -1) { perror(\u0026#34;open error\u0026#34;); return; } if (flock_sh(fd) != -1) { do_something(); } log(\u0026#34;close %d\u0026#34;, fd); close(fd); } void *thread_start(void *notused) { do_something_wrap(); return NULL; } void fork_exec() { pid_t pid = fork(); if (pid == 0) { log(\u0026#34;In child\u0026#34;); execl(\u0026#34;/bin/bash\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;./do.sh\u0026#34;, NULL); exit(0); } else { waitpid(pid, NULL, WUNTRACED); } } int main(int argc, char **argv) { log(\u0026#34;main\u0026#34;); pthread_t tid = spawn(thread_start, NULL); sleep(1); fork_exec(); pthread_join(tid, NULL); return 0; }   do.sh:\n1 2 3  echo \u0026#34;[shell]=====start=====\u0026#34; flock -x f.lock echo \u0026#34;[shell]in flock ex\u0026#34; echo \u0026#34;[shell]======end======\u0026#34;   程序在子进程中打开锁文件，尝试获取共享锁，然后关闭文件。\n打印日志如下：\n1 2 3 4 5 6 7  $ [p15641][t140500877805376]main [p15641][t140500877801024]open ./f.lock as 3 [p15641][t140500877801024]flock sh, fd: 3 [p15641][t140500877801024]do some things... [p15643][t140500877805376]In child [shell]=====start===== [p15641][t140500877801024]close 3   使用top，可以看到三个被卡住的进程\n1 2 3  15641 lcl 20 0 10960 1108 1016 S 0.0 0.0 0:00.00 fl 15643 lcl 20 0 7752 3372 3124 S 0.0 0.0 0:00.00 bash 15644 lcl 20 0 6172 944 856 S 0.0 0.0 0:00.00 flock   使用strace查看\n1 2 3 4 5 6 7 8 9  $ strace -p 15641 strace: Process 15641 attached wait4(15643, $ strace -p 15643 strace: Process 15643 attached wait4(-1, $ strace -p 15644 strace: Process 15644 attached flock(4, LOCK_EX   fl主程序卡在wait，shell脚本的flock命令卡在等待文件锁上。但是我们的程序中文件已经关闭了，为什么flock会被卡住呢？ 通过proc信息查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ ls -l /proc/15641/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 $ ls -l /proc/15643/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 lr-x------ 1 lcl lcl 64 Oct 28 20:01 255 -\u0026gt; /home/lcl/repo/c/flock/do.sh l-wx------ 1 lcl lcl 64 Oct 28 20:01 3 -\u0026gt; /home/lcl/repo/c/flock/f.lock $ ls -l /proc/15644/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 l-wx------ 1 lcl lcl 64 Oct 28 20:01 3 -\u0026gt; /home/lcl/repo/c/flock/f.lock lr-x------ 1 lcl lcl 64 Oct 28 20:01 4 -\u0026gt; /home/lcl/repo/c/flock/f.lock   可以看到在PID15643和PID15644中，指向f.lock的fd 3依然存在，只是在PID15641中被关闭了。 所以这是一个文件锁、多进程多线程文件继承的问题。在线程中打开的文件，被子进程继承，当关闭文件时，执行了exec的子进程已经断开和原主进程的关系，打开的文件得以保留。因此f.lock这个文件并没有被所有进程关闭，挂在这个文件上的锁也没有被解锁，导致了死锁问题。\n其过程如下： 其解决方案是，使用显式的UNLOCK进行解锁，再设置文件的close_on_exec属性加一重保险。\n"},{"id":4,"href":"/post/msm/","title":"boost meta state machine","section":"Posts","content":"MSM Meta State Machine，是boost库的元状态机，使用了大量的模板元编程，让使用者轻松创建出好用，可阅读，效率高的状态机。它的特点是使用状态转移表 transition_table 来定义状态机转移的过程，非常直观，易于阅读，修改，排错和修改。状态转移表的要素是源状态 Sourcce State，目标状态 Target State，触发事件Event，守卫条件Guard和执行动作Action。\n本文代码示例在boost_msm_guide\n从一个简单的状态机开始 #  使用boost msm定义一个简单的状态机分为6步：\n 定义事件Event 定义状态机front-end boost::msm::front::state_machine_def 定义状态 设置初始状态 定义状态转移表 生成状态机back-end  状态机使用时\n 定义状态机实例fsm 开始状态机fsm.start() 处理事件fsm.process_event()  首先从一个只有状态转移的简单状态机开始\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;boost/msm/back/state_machine.hpp\u0026gt;#include \u0026lt;boost/msm/front/state_machine_def.hpp\u0026gt;#include \u0026lt;boost/msm/front/functor_row.hpp\u0026gt;#include \u0026lt;iostream\u0026gt; namespace { // ---Events  struct Event1 {}; // ---State Machine front-end  struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // States  struct State1 : boost::msm::front::state\u0026lt;\u0026gt; { // Entry Action  template\u0026lt;class Event, class Fsm\u0026gt; void on_entry(Event const\u0026amp;, Fsm\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;Entering State1\\n\u0026#34;; } // Exit Action  template\u0026lt;class Event, class Fsm\u0026gt; void on_exit(Event const\u0026amp;, Fsm\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;Leaving State1\\n\u0026#34;; } }; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // Set initial state  using initial_state = State1; // Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start | Event | Next | Action | Guard  _row\u0026lt; State1, Event1, End \u0026gt; \u0026gt; {}; }; // Pick a back-end  using Fsm = boost::msm:🔙:state_machine\u0026lt;Sm\u0026gt;; void test() { Fsm fsm; fsm.start(); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event1\\n\u0026#34;; fsm.process_event(Event1{}); } } int main() { test(); return 0; }   编译运行此状态，打印是\n1 2 3  Entering State1 \u0026gt; Send Event1 Leaving State1   State #  状态机的第一要素当然是状态，一个状态机的一生就是在各个状态间来来去去。状态间的迁移由Event事件触发，迁移中间可以执行Action，是否能迁移取决于Guard。每个状态带有on_entry和on_exit两个方法，顾名思义，在进入和离开时触发。\n为了后续更好的演示，我们定义一个base class执行一些基础的打印。\n首先，获取type的名称。我们知道标准库中的typeid(var).name()方法可以获取到变量的类型名称，但是是内部的符号，我们可以通过boost::core::demangle方法来获取更易读的名称，同时把命名空间的前缀去掉。\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; std::string get_typename(const T \u0026amp;x) { std::string name = boost::core::demangle(typeid(x).name()); auto pos = name.rfind(\u0026#34;::\u0026#34;); if (pos != std::string::npos) { name = name.substr(pos + 2); } return name; }   BaseState负责在on_entry和on_exit时打印日志，这两个方法由状态机在进入和离开状态时自动调用。为了继承的子类可以定制一些动作，定义了虚函数prepare和clean，参数为状态机内的ctx。实际上，这里和on_entry一样传入template Event和Fsm参数更好，但是由于c++语言的限制，模板函数不能为虚函数，所以退而求其次，传入一个新的Context变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct BaseState : boost::msm::front::state\u0026lt;\u0026gt; { virtual ~BaseState() {} template\u0026lt;class Event, class Fsm\u0026gt; void on_entry(Event const \u0026amp;event, Fsm \u0026amp;fsm) { std::cout \u0026lt;\u0026lt; \u0026#34;[state]...Entering \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; prepare(fsm.ctx); } template\u0026lt;class Event, class Fsm\u0026gt; void on_exit(Event const \u0026amp;event, Fsm \u0026amp;fsm) { std::cout \u0026lt;\u0026lt; \u0026#34;[state]...Leaving \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; clean(fsm.ctx); } virtual void prepare(Context \u0026amp;) {} virtual void clean(Context \u0026amp;) {} };   现在，我们的状态机得以精简\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // ---States  struct State1 : BaseState {}; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // ---Set initial state  using initial_state = State1; // ---Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start | Event | Next | Action | Guard  _row\u0026lt; State1, Event1, End \u0026gt; \u0026gt; {}; Context ctx; }; // ---Pick a back-end using Fsm = boost::msm:🔙:state_machine\u0026lt;Sm\u0026gt;;   打印是\n1 2 3  [state]...Entering State1 by InitEvent \u0026gt; Send Event1 [state]...Leaving State1 by Event1   值得注意的是InitEvent，它是从哪来的？我们的transition_table并没有定义这个事件！实际上，这是Fsm进入initial_state的默认触发事件。\nAction #  Action发生在离开状态后，进入下一状态前。可以使用一个Functor class来表示。和State一样，这里定义一个BaseAction的类。\n1 2 3 4 5 6 7 8 9 10 11  struct BaseAction { virtual ~BaseAction() {} template\u0026lt;class Event, class Fsm, class SourceState, class TargetState\u0026gt; void operator()(Event const \u0026amp;event, Fsm \u0026amp;fsm, SourceState const \u0026amp;from, TargetState const \u0026amp;to) { std::cout \u0026gt;\u0026gt; \u0026#34;[action] Do \u0026#34; \u0026gt;\u0026gt; get_typename(*this) \u0026gt;\u0026gt; \u0026#34; from \u0026#34; \u0026gt;\u0026gt; \u0026gt;\u0026gt; get_typename(from) \u0026gt;\u0026gt; \u0026#34; to \u0026#34; \u0026gt;\u0026gt; get_typename(to) \u0026gt;\u0026gt; \u0026gt;\u0026gt; \u0026#34; by \u0026#34; \u0026gt;\u0026gt; get_typename(event) \u0026gt;\u0026gt; \u0026#34;\\n\u0026#34;; execute(fsm.ctx); } virtual void execute(Context \u0026amp;) {} };   Guard #  Guard发生在离开状态前，返回一个bool值，如果为true，则可以转移，否则保持在原状态。\n1 2 3 4 5 6 7 8 9 10 11 12  struct BaseGuard { virtual ~BaseGuard() {} template\u0026lt;class Event, class Fsm, class SourceState, class TargetState\u0026gt; bool operator()(Event const \u0026amp;event, Fsm \u0026amp;fsm, SourceState const \u0026amp;from, TargetState const \u0026amp;to) { bool ok = execute(fsm.ctx); std::cout \u0026lt;\u0026lt; \u0026#34;[guard] \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; ok \u0026lt;\u0026lt; \u0026#34; from \u0026#34; \u0026lt;\u0026lt; get_typename(from) \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; get_typename(to) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return ok; } virtual bool execute(Context \u0026amp;) {return true;} };   transition_table #  状态转移表的完整形态是5个元素： fromState， Event， ToState， Action， Guard 一般使用functor_row里的boost::msm::front::Row来定义转移表的每一行。其中空的要素使用boost::msm::front::none来表示。 可以使用using来简化这个两个类型\n1 2 3 4  template\u0026lt;typename... T\u0026gt; using Row = boost::msm::front::Row\u0026lt;T...\u0026gt;; using None = boost::msm::front::none;   至此我们可以写一个完整的状态了。\n代码为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // ---State Machine front-end struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // ---States  struct State1 : BaseState {}; struct State2 : BaseState {}; struct Init : BaseState {}; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // ---Events  struct Event1 {}; struct Event2 {}; // ---Actions  struct Action1 : BaseAction {}; struct Action2 : BaseAction {}; // ---Guard  struct Guard1 : BaseGuard {}; struct GTrue : BaseGuard {}; struct GFalse : BaseGuard { bool execute(Context \u0026amp;) override { return false; } }; // ---Set initial state  using initial_state = Init; template\u0026lt;typename... T\u0026gt; using Row = boost::msm::front::Row\u0026lt;T...\u0026gt;; using None = boost::msm::front::none; // ---Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, State2, Action1, Guard1 \u0026gt;, Row\u0026lt; State2, Event2, End, Action2, None \u0026gt; \u0026gt; {}; Context ctx; }; // ---Pick a back-end using Fsm = boost::msm:🔙:state_machine\u0026lt;Sm\u0026gt;; void test() { Fsm fsm; fsm.start(); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event1\\n\u0026#34;; fsm.process_event(Event1{}); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event2\\n\u0026#34;; fsm.process_event(Event2{}); }   输出为\n1 2 3 4 5 6 7 8 9 10 11  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] Guard1 -\u0026gt; true from State1 to State2 by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to State2 by Event1 [state]...Entering State2 by Event1 \u0026gt; Send Event2 [state]...Leaving State2 by Event2 [action] Do Action2 from State2 to End by Event2   if-else #  在transition_table中，在下方的row优先于上方的row先执行。\n这一节通过实现一个if-else的逻辑来说明在transition_table里row的优先级。\n两个Action\n1 2 3 4 5 6 7 8 9 10 11  // ---Actions struct SetVal1 : BaseAction { void execute(Context \u0026amp;ctx) override { ctx.val = 1; } }; struct SetVal2 : BaseAction { void execute(Context \u0026amp;ctx) override { ctx.val = 2; } };   Guard\n1 2 3 4 5  struct IfGuard : BaseGuard { bool execute(Context \u0026amp;ctx) override { return ctx.val == 1; } };   transition_table\n1 2 3 4 5 6 7 8 9 10  // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init , Event1 , State1 , SetVal1 , None \u0026gt;, Row\u0026lt; Init , Event2 , State1 , SetVal2 , None \u0026gt;, Row\u0026lt; State1 , None , ElseState , None , None \u0026gt;, Row\u0026lt; State1 , None , IfState , None , IfGuard\u0026gt;, Row\u0026lt; IfState, None , Init , None , None \u0026gt;, Row\u0026lt; ElseState, None , Init , None , None \u0026gt; \u0026gt; {};   输出为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [state]...Entering Init by InitEvent \u0026gt; Send Event1 [state]...Leaving Init by Event1 [action] Do SetVal1 from Init to State1 by Event1 [state]...Entering State1 by Event1 [guard] IfGuard -\u0026gt; true from State1 to IfState by none [state]...Leaving State1 by none [state]...Entering IfState by none [state]...Leaving IfState by none [state]...Entering Init by none \u0026gt; Send Event2 [state]...Leaving Init by Event2 [action] Do SetVal2 from Init to State1 by Event2 [state]...Entering State1 by Event2 [guard] IfGuard -\u0026gt; false from State1 to IfState by none [state]...Leaving State1 by none [state]...Entering ElseState by none [state]...Leaving ElseState by none [state]...Entering Init by none   状态自转移 #  转移到自己本身有两种方式，可以称为外部自转移和内部自转移。如\n1 2 3 4 5 6 7  // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, State1, Action1, Guard1 \u0026gt;, Row\u0026lt; State1, Event2, None , Action2, GTrue \u0026gt; \u0026gt; {};    start和next都是State1，此时会执行State1的on_exit和on_entry。 next时None，不会执行on_exit和on_entry。  1 2 3 4 5 6 7 8 9 10 11  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] Guard1 -\u0026gt; true from State1 to State1 by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to State1 by Event1 [state]...Entering State1 by Event1 \u0026gt; Send Event2 [guard] GTrue -\u0026gt; true from State1 to State1 by Event2 [action] Do Action2 from State1 to State1 by Event2   exception #  状态机的on_entry, on_exit, Action, Guard都可能抛出异常，不自己处理的话，程序会异常退出。可以通过自己定义exception_caught方法来自定义异常处理。 另外我们可以重载no_transition的方法来处理没有对应状态转移规则的情况。 例如：\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;class Event, class Fsm\u0026gt; void exception_caught (Event const\u0026amp; evt, Fsm\u0026amp; fsm,std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;catch exception \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34; while \u0026#34; \u0026lt;\u0026lt; get_typename(evt) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;class Event, class Fsm\u0026gt; void no_transition(Event const\u0026amp; evt, Fsm \u0026amp;fsm, int x) { std::cout \u0026lt;\u0026lt; \u0026#34;No transition item for \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; while \u0026#34; \u0026lt;\u0026lt; get_typename(evt) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   针对产生异常的不同时机，其表现有所不同。我们通过一个out_of_range的异常来看一下实际结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void sth_wrong() { std::vector\u0026lt;int\u0026gt; a(1); int i = a.at(2); } struct ExceptionOnEntry : BaseState { void prepare(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionOnExit : BaseState { void clean(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionAction : BaseAction { void execute(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionGuard : BaseGuard { bool execute(Context \u0026amp;) override { sth_wrong(); return true; } }; // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, ExceptionOnEntry, Action1, GTrue \u0026gt;, Row\u0026lt; State1, Event2, State2, ExceptionAction, GTrue \u0026gt;, Row\u0026lt; State1, Event3, State2, Action1, ExceptionGuard \u0026gt;, Row\u0026lt; State1, Event4, ExceptionOnExit, Action1, GTrue \u0026gt;, Row\u0026lt; ExceptionOnExit, Event5, State1, Action1, GTrue \u0026gt; \u0026gt; {};   运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] GTrue -\u0026gt; true from State1 to ExceptionOnEntry by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to ExceptionOnEntry by Event1 [state]...Entering ExceptionOnEntry by Event1 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event1 \u0026gt; Send Event2 [guard] GTrue -\u0026gt; true from State1 to State2 by Event2 [state]...Leaving State1 by Event2 [action] Do ExceptionAction from State1 to State2 by Event2 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event2 \u0026gt; Send Event3 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event3 \u0026gt; Send Event4 [guard] GTrue -\u0026gt; true from State1 to ExceptionOnExit by Event4 [state]...Leaving State1 by Event4 [action] Do Action1 from State1 to ExceptionOnExit by Event4 [state]...Entering ExceptionOnExit by Event4 \u0026gt; Send Event5 [guard] GTrue -\u0026gt; true from ExceptionOnExit to State1 by Event5 [state]...Leaving ExceptionOnExit by Event5 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event5 \u0026gt; Send Event1 No transition item for 2 while Event1   可以总结： 一次状态迁移的过程分为guard-\u0026gt;on_exit-\u0026gt;action-\u0026gt;on_entry。其中某一步抛出异常时，状态都会回到sourceState。\n"},{"id":5,"href":"/post/hugo_and_git_submodule/","title":"Hugo and git submodule","section":"Posts","content":"介绍 #  hugo + gitee搭建个人博客，使用gitee代替github是因为国内访问速度问题。\nhugo直接在仓库可以安装sudo apt install hugo，这个链接是它的官方网页。\nhugo new xxx.md在post中新建Markdown格式的文章，注意此时在开头属性里有draft: true的标志，这会导致此篇文章不能发布。 后期需要删除此行。\nhugo -t $theme生成public文件夹中的静态网页。\nhugo server可以本地起一个服务器，这时通过浏览器查看网页效果。\ngit submodule #  hugo主题和静态网页是另外的git库，为了方便管理，引入git submodule的用法。\n比如我使用的hugo主题是even，可以使用命令\n1  git submodule add https://gitee.com/xxxxx/hugo-theme-even.git themes/even   来添加子模块。\ngitee提供的静态网页，在仓库的服务-\u0026gt;Gitee Pages可以找到。即新建一个同名的仓库就可以了。同样添加\n1  git submodule add -b master https://gitee.com/lclei/lclei.git public   添加后，主目录里会有.gitmodules文件记录。\n1 2 3 4 5 6 7 8  $ cat .gitmodules [submodule \u0026#34;themes/even\u0026#34;] path = themes/even url = https://gitee.com/gkzhb/hugo-theme-even.git [submodule \u0026#34;public\u0026#34;] path = public url = https://gitee.com/lclei/lclei.git branch = master   git没有提供submodule的删除命令。有出错等情况，可以去.git目录下找到modules目录，删除对应submodule。\n部署 #  最后记录自己的deploy.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to Gitee...\\033[0m\\n\u0026#34; # Build the project. hugo -t even # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master cd ..   "},{"id":6,"href":"/post/non_cursive_tree_traversal/","title":"二叉树的非递归遍历","section":"Posts","content":"二叉树的遍历有前序，中序，后序以及层次遍历，其中前序，中序和后序遍历使用递归来写非常简单。 例如\n1 2 3 4 5 6 7  void tree_preorder_re(TreeNode *node, Tree *tree, void (*visit)(Tree *, TreeNode *)) { if (!node) return; visit(tree, node); tree_preorder_re(node-\u0026gt;left, tree, visit); tree_preorder_re(node-\u0026gt;right, tree, visit); }   中序和后序，不过是调整一下visit的位置，如果不用递归的写法，改用栈来实现，其实没有那么直观。 首先按照函数调用的关系，入栈的套路都是一样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while (stack_depth(s) != 0 || tNode) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); tNode = tNode-\u0026gt;right; } } stack_free(s);   前序遍历 #  前序遍历最简单，在节点入栈的时候访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void tree_preorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while (stack_depth(s) != 0 || tNode) { while (tNode != NULL) { stack_push(s, tNode); visit(tree, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); tNode = tNode-\u0026gt;right; } } stack_free(s); }   中序遍历 #  在节点出栈的时候访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void tree_inorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while(stack_depth(s) != 0 || tNode != NULL) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); visit(tree, tNode); tNode = tNode-\u0026gt;right; } } stack_free(s); }   后序遍历 #  保证左右节点都访问之后，再访问父节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void tree_postorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; TreeNode *last_visit = NULL; while(tNode != NULL || !stack_is_empty(s)) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_top(s); if (tNode-\u0026gt;right == NULL || tNode-\u0026gt;right == last_visit) { stack_pop(s); last_visit = tNode; visit(tree, tNode); tNode = NULL; } else { tNode = tNode-\u0026gt;right; } } } stack_free(s); }   验证\n1 2 3 4 5 6 7 8 9 10 11 12  main(251): __debug preorder recursive--- 1 2 4 5 3 6 7 main(254): __debug preorder non-recursive--- 1 2 4 5 3 6 7 main(257): __debug inorder recursive--- 4 2 5 1 6 3 7 main(260): __debug inorder non-recursive--- 4 2 5 1 6 3 7 main(263): __debug postorder recursive--- 4 5 2 6 7 3 1 main(266): __debug postorder non_ecursive--- 4 5 2 6 7 3 1   "},{"id":7,"href":"/post/udisk-grub/","title":"使用grub创建多系统u盘安装盘","section":"Posts","content":"现在装系统都是用u盘安装了，一个u盘只能安装一个系统有些浪费了，因为空间足够大，可以装下好几个iso文件。 在linux环境中，使用dd命令只能制作一个引导盘，且其他空间不能再使用。从网上看用YUMI可以比较方便的制作多系统引导。然而实测发现是linux系统上实在太难用，装WINE也用不了。后来看到grub的方法成功实现了。\ngrub的方法分为两步：\n 对u盘分区，拷入iso文件 安装grub，编辑grub.cfg  u盘分区 #  首先可以找一找是否有现成的分区软件可以用，比如manjaro-kde自带的KDE partion manager。\n下面还是给出fdisk的命令来复盘整个过程。\n1 2 3 4 5 6 7 8 9 10  sudo su # 提升权限方便后续操作 fdisk -l # 查看当前分区，查找到u盘对应的位置，比如/dev/sdb mkfs /dev/sdb # 格式化 fdisk /dev/sdb # 分区开始 d # 删除原分区 n # 新分区 a # 增加引导标志 t # 更改类型 w # 写入保存 m # 看help   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  I. Format your USB Flash Drive to use a Single Partition: Open a terminal and type sudo su Type fdisk -l (and note which device is your USB Drive) Type fdisk /dev/sdx (replacing x with your actual usb device) Type d (to delete the existing partition) Type n (to create a new partition) Type p (for primary partition) Type 1 (to create the first partition) Press Enter (to use the first cylinder) Press Enter again (to use the default value as the last cylinder) Type a (for active) Type 1 (to mark the first partition active \u0026#34;bootable\u0026#34;) Type t (for partition type) Type c (to use fat32 partition) Type w (to write the changes and close fdisk) II. Create a Fat32 Filesystem on the USB Flash Drive: Type umount /dev/sdx1 (to unmount the mounted partition) Type mkfs.vfat -F 32 -n MULTIBOOT /dev/sdx1 (to format the partition as fat32) Remove and reinsert your USB flash drive, or remount it   grub #  挂载，安装grub\n1 2  mount /dev/sdb1 /mnt/udisk/linux/ grub-install --root-directory=/mnt/udisk/linux/ --boot-directory=/mnt/udisk/linux/boot/ --no-floppy /dev/sdb   grub配置，各linux发行版的grub menu都不太一样，需要从网上查找以及和iso中的文件进行比对，我现在用的manjaro和ubuntu的配置如下，亲测可以使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  set timeout=10 insmod fat set default=0 loadfont /boot/grub/fonts/unicode.pf2 set gfxmode=1920x1080 set theme=\u0026#34;/boot/grub/themes/starfield/theme.txt\u0026#34; export theme set gfxpayload=keep insmod gfxterm insmod vbe insmod loopback insmod iso9660 terminal_output gfxterm insmod jpeg background_image /boot/grub/grub.jpg setmenu_color_normal=white/black setmenu_color_highlight=black/light-gray set USBUUID=\u0026#34;306B-1C5B\u0026#34; menuentry \u0026#34;manjaro-kde-2012\u0026#34; --class manjaro{ set isofile=\u0026#34;/iso/manjaro-kde-20.1.2-201019-linux58.iso\u0026#34; set dri=\u0026#34;free\u0026#34; search --no-floppy -f --set=root $isofile probe -u $root --set=abc set pqr=\u0026#34;/dev/disk/by-uuid/$abc\u0026#34; loopback loop $isofile linux (loop)/boot/vmlinuz-x86_64 img_dev=$pqr img_loop=$isofile driver=$dri lang=zh_CN initrd (loop)/boot/intel_ucode.img (loop)/boot/initramfs-x86_64.img } menuentry \u0026#34;Ubuntu2004\u0026#34; { set isofile=\u0026#34;/iso/ubuntu-20.04.1-desktop-amd64.iso\u0026#34; loopback loop $isofile linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile locale=zh_CN.UTF-8 initrd (loop)/casper/initrd } menuentry \u0026#34;System shutdown\u0026#34; --class shutdown { echo \u0026#34;System shutting down...\u0026#34; halt } menuentry \u0026#34;System restart\u0026#34; --class restart { echo \u0026#34;System rebooting...\u0026#34; reboot }   "},{"id":8,"href":"/post/rvalue/","title":"右值引用","section":"Posts","content":"右值引用 #   使用\u0026amp;\u0026amp;表示 只能绑定到一个将要销毁的对象 左值持久，右值短暂 将左值转换为对应的右值使用std::move  1 2 3 4 5 6  int i = 42; int \u0026amp;r = i; //左值引用，ok int \u0026amp;\u0026amp;rr = i; //错误，不能把右值引用绑定到左值上 int \u0026amp;r2 = i*42; //错误，i*42是一个右值 const int \u0026amp;r3 = i*42; //ok，const引用可以绑定到右值 int \u0026amp;\u0026amp;rr2 = i*42; //ok，右值引用绑定右值   移动构造和移动赋值 #  例如这样一个类StrVec中有移动构造和移动赋值，使用\u0026amp;\u0026amp;作为参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132  // StrVec class, a class like vector but only store string as element // CppPrimer 13.5 // lcl 20190712  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;memory\u0026gt;using namespace std; class StrVec { public: StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr){} StrVec(const StrVec \u0026amp;); // copy constructor  StrVec(StrVec \u0026amp;\u0026amp;) noexcept; // move constructor  StrVec \u0026amp;operator=(const StrVec\u0026amp;); // copy assignment  StrVec \u0026amp;operator=(StrVec\u0026amp;\u0026amp;) noexcept; //move assignment  ~StrVec(); void push_back(const std::string\u0026amp;); size_t size() const {return first_free - elements;} size_t capacity() const {return cap - elements;} std::string *begin() const { return elements;} std::string *end() const { return first_free;} private: std::allocator\u0026lt;std::string\u0026gt; alloc; void chk_n_alloc() { if(size()==capacity()) reallocate(); } std::pair\u0026lt;std::string*, std::string*\u0026gt; alloc_n_copy (const std::string*, const std::string*); void free(); void reallocate(); std::string *elements; //point to first element  std::string *first_free; //point to first free element  std::string *cap; //point to rear; }; void StrVec::push_back(const string\u0026amp; s) { chk_n_alloc(); alloc.construct(first_free++, s); } pair\u0026lt;string*, string*\u0026gt; StrVec::alloc_n_copy(const string *b, const string* e) { auto data = alloc.allocate(e-b); return {data, uninitialized_copy(b,e,data)}; } void StrVec::free() { if(elements){ for(auto p = first_free; p!=elements;alloc.destroy(--p)); alloc.deallocate(elements, cap-elements); } } StrVec::StrVec(const StrVec\u0026amp;s) { auto newdata = alloc_n_copy(s.begin(), s.end()); elements = newdata.first; first_free = cap = newdata.second; } StrVec::~StrVec() { free(); } StrVec\u0026amp; StrVec::operator=(const StrVec \u0026amp;rhs) { // 先分配大小相同的内存拷贝，再释放掉原data  auto data = alloc_n_copy(rhs.begin(), rhs.end()); free(); elements = data.first; first_free = cap = data.second; return *this; } void StrVec::reallocate() { auto newcapacity = size() ? 2 * size() : 1; auto newdata = alloc.allocate(newcapacity); auto dest = newdata; auto elem = elements; for( size_t i = 0; i!=size();++i) // 使用了std::move，从而会调用移动构造函数  alloc.construct(dest++,std::move(*elem++)); free(); elements = newdata; first_free = dest; cap = elements + newcapacity; } StrVec::StrVec(StrVec \u0026amp;\u0026amp;s) noexcept //移动操作不抛出任何异常  :elements(s.elements), first_free(s.first_free), cap(s.cap) { // 令s进入这样的状态，对其进行析构是安全的？  // 这里令元素为空，析构函数将不能释放空间  // 因为元素已经转给移动后的对象，空间不应该释放，所以令他们为空  s.elements = s.first_free = s.cap = nullptr; } // 使用noexcept告知编译器不会抛出异常  StrVec\u0026amp; StrVec::operator=(StrVec \u0026amp;\u0026amp;rhs) noexcept { // 处理自赋值的情况  if(this != \u0026amp;rhs){ free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; } } // test int main(int argc, char* argv[]) { StrVec sv,sv1; std::cout \u0026lt;\u0026lt; sv.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sv.capacity() \u0026lt;\u0026lt; std::endl; sv.push_back(\u0026#34;first line\u0026#34;); sv.push_back(\u0026#34;second_line\u0026#34;); sv1 = sv; std::cout \u0026lt;\u0026lt; sv1.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sv1.capacity() \u0026lt;\u0026lt; std::endl; }   "},{"id":9,"href":"/post/polymorphism/","title":"多态 polymorphism","section":"Posts","content":"多态 polymorphism #   一个接口，多种方法 使用虚函数实现  基类成员函数添加了virtual关键字，该函数在执行时绑定。否则在编译时绑定。所以\n基类希望其派生类进行覆盖的函数，定义为虚函数\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; class Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;??\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat : public Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;Miao Miao\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog : public Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;Wang Wang\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(int argc, char **argv){ Animal *animal; animal = new Cat; animal-\u0026gt;sound(); animal = new Dog; animal-\u0026gt;sound(); }   输出\n lcl@FX50JK:~/Documents/hub/learning-record/cpp$ ./polymorphism\n??\n??\n 可见animal指针虽然指向子类Cat和Dog，但是并没用他们的sound方法。基类使用virtual关键字\n1 2 3 4 5 6  class Animal{ public: virtual void sound(){ cout \u0026lt;\u0026lt; \u0026#34;??\u0026#34; \u0026lt;\u0026lt; endl; } };   输出\n lcl@FX50JK:~/Documents/hub/learning-record/cpp$ ./polymorphism\nMiao Miao\nWang Wang\n"},{"id":10,"href":"/post/smartpointer/","title":"智能指针","section":"Posts","content":" #include \u0026lt;memory\u0026gt;\n 三种智能指针\nshared_ptr #  有引用计数，当最后一个shared_ptr被销毁，其指向的对象将被析构。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;iterator\u0026gt; using namespace std; class Foo{ public: Foo() {p = new int[10];cout \u0026lt;\u0026lt; \u0026#34;new@\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt;endl;} ~Foo() {cout \u0026lt;\u0026lt; \u0026#34;release@\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;delete [] p;p=nullptr;} int *p; }; void smartptr() { shared_ptr\u0026lt;Foo\u0026gt; sp1 = make_shared\u0026lt;Foo\u0026gt;(); auto sp2 = make_shared\u0026lt;Foo\u0026gt;(); } void ptr() { auto p = new Foo; } int main(int argc,char* argv[]) { smartptr(); ptr(); return 0; }   其输出结果为\n new@0x1001370 new@0x10013b8 release@0x10013b8 release@0x1001370 new@0x1001368\n make_shared\u0026lt;\u0026gt;是库函数，将会new一个对象，然后绑定到shared_ptr\n 在子函数smartptr中两个临时变量是共享指针，在退出子函数时会被销毁，销毁时调用了对象的析构函数。 而ptr函数里只是普通指针，退出销毁时没有调用析构函数，造成内存泄漏。  删除器\n使用智能指针还可以定义自己的释放操作，这是针对那些没有合适析构函数的对象或是c语言的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;memory\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; typedef int fd; fd fileid = 0; fd open() { cout \u0026lt;\u0026lt; \u0026#34;open \u0026#34; \u0026lt;\u0026lt; fileid \u0026lt;\u0026lt; endl; return fileid++; } void close(fd f) { cout \u0026lt;\u0026lt; \u0026#34;close \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; fileid--; } void end_fd(fd* f){close(*f);} void foo() { fd g = open(); shared_ptr\u0026lt;fd\u0026gt; sp(\u0026amp;g,end_fd); } int main(int argc, char *argv[]) { foo(); }   输出\n open 0 close 0\n 需要注意的是传入的删除器函数的参数必须是智能指针保存的指针类型才可以通过编译。\nunique_ptr #  不能拷贝，不能赋值，拥有指向的对象\n可以直接初始化\n1  unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;I am unique\u0026#34;))   1  unique_ptr\u0026lt;string\u0026gt; p2(p1); //错误，不支持拷贝   1 2  unique_ptr\u0026lt;string\u0026gt; p2; p2=p1;//错误，不支持赋值   需要转移控制权的话，可以用\n1  unique_ptr\u0026lt;string\u0026gt; p2(p1.release())   或者\n1 2  unique_ptr\u0026lt;string\u0026gt; p2; p2.reset(p1.release());   weak_ptr #  需要一个shared_ptr来初始化它，不影响shared_ptr的计数\n1  weak_ptr\u0026lt;T\u0026gt; wp(sp)   操作\n1 2 3 4  wp.reset() //置为空 wp.use_count() //返回指向对象的shared_ptr的数量 wp.expired() //wp.use_count()为0，返回true wp.lock() //wp.expired()为true，则返回一个共享的shared_ptr，否则返回一个空的shared_ptr   weak_ptr的作用就是辅助shared_ptr的，比如解决shared_ptr相互引用的问题而不能释放的问题。\n"},{"id":11,"href":"/post/docker1/","title":"docker1","section":"Posts","content":"初探docker #  我的centos挂掉了，折腾了一两天没有成效，暂时不做他想，可能需要重装了吧。之前在win10上用VMware，老破电脑太卡，机缘巧合之下，我了解到docker是轻量级的虚拟机，来试一下。\n下载win10版本，安装后有Docker Desktop，一看内存占用，嗬，满的，别慌，先setting一下 Memory当然选最小，OK，勉强可以使用了。 接下来，打开cmd，开始docker历程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  C:\\Users\\Administrator\u0026gt;docker version Client: Docker Engine - Community Version: 18.09.2 API version: 1.39 Go version: go1.10.8 Git commit: 6247962 Built: Sun Feb 10 04:12:31 2019 OS/Arch: windows/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.2 API version: 1.39 (minimum version 1.12) Go version: go1.10.6 Git commit: 6247962 Built: Sun Feb 10 04:13:06 2019 OS/Arch: linux/amd64 Experimental: false   1 2 3  C:\\Users\\Administrator\u0026gt;docker search tutorial NAME DESCRIPTION STARS OFFICIAL AUTOMATED learn/tutorial 40   1 2 3 4 5 6  C:\\Users\\Administrator\u0026gt;docker pull learn/tutorial Using default tag: latest latest: Pulling from learn/tutorial 271134aeb542: Pull complete Digest: sha256:2933b82e7c2a72ad8ea89d58af5d1472e35dacd5b7233577483f58ff8f9338bd Status: Downloaded newer image for learn/tutorial:latest   1 2  C:\\Users\\Administrator\u0026gt;docker run learn/tutorial echo \u0026#34;hello world\u0026#34; hello world   一套素质三连，出现了classical的hello world.\n使用-it，可以得到Linux终端体验： -t 让docker分配一个伪终端 -i 让容器的标准输入保持打开\n1 2 3 4  C:\\Users\\Administrator\u0026gt;docker run -it learn/tutorial /bin/bash root@ce6e965e57f4:/# echo \u0026#34;Here is like a real bash\u0026#34; Here is like a real bash root@ce6e965e57f4:/#   "},{"id":12,"href":"/post/docker2/","title":"docker2","section":"Posts","content":"搭建开发环境 #  首先还是从centos入手吧\n1 2 3  C:\\Users\\Administrator\u0026gt;docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 5221 [OK]   选择一个官方的版本，pull下来\n1  docker run -it centos   这是一个没有vim，没有gcc，没有gdb的世界，安装他们\n1 2 3  yum install vim yum install gcc yum install gdb   于是在windows的docker下，我们可以继续愉快的code了。\n\u0026ndash;然而 实测发现gdb不能用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  [root@1bb163f86a43 lcl]# gdb hello GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-redhat-linux-gnu\u0026#34;. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;... Reading symbols from /lcl/hello...done. (gdb) l 1 #include \u0026lt;stdio.h\u0026gt; 2 3 int main() 4 { 5 printf(\u0026#34;hello world!\\n\u0026#34;); 6 return 0; 7 } (gdb) r Starting program: /lcl/hello warning: Error disabling address space randomization: Operation not permitted Cannot create process: Operation not permitted During startup program exited with code 127.   参考这篇 https://blog.csdn.net/snipercai/article/details/80408569\n1 2 3  C:\\Users\\Administrator\u0026gt;docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1bb163f86a43 centos/gcc \u0026#34;/bin/bash\u0026#34; 45 minutes ago Exited (0) 16 minutes ago pensive_ramanujan   记住这个ID，commit它\n1 2 3 4 5 6 7 8 9  C:\\Users\\Administrator\u0026gt;docker commit 1bb develop sha256:30f0327ebe65560ebd78daf868c1835c0d97ee1c2ff95450ec1ebd848cb57cc7 C:\\Users\\Administrator\u0026gt;docker images REPOSITORY TAG IMAGE ID CREATED SIZE develop latest 30f0327ebe65 6 seconds ago 493MB centos/gcc latest f1af98e3ed8a 22 hours ago 408MB centos latest 1e1148e4cc2c 2 months ago 202MB learn/tutorial latest a7876479f1aa 5 years ago 128MB   现在得到了images develop，以后就用它吧\n"},{"id":13,"href":"/post/docker3/","title":"docker3","section":"Posts","content":"docker容器操作 #  让我们再梳理一遍这样的事实：镜像image运行产生容器container，镜像可以保存为镜像 查看容器\n1 2 3 4  C:\\WINDOWS\\system32\u0026gt;docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f3c6f9f95723 develop \u0026#34;/bin/bash\u0026#34; 27 hours ago Up 10 minutes modest_lovelace 5543700d2439 develop \u0026#34;/bin/bash\u0026#34; 7 days ago Exited (1) 6 days ago modest_edison   运行容器，可以只简写3个字母代表ID\n1 2 3 4  C:\\WINDOWS\\system32\u0026gt;docker start f3c f3c C:\\WINDOWS\\system32\u0026gt;docker attach f3c   多开窗口\n1 2  C:\\Users\\Administrator\u0026gt;docker exec -it f3c bash [root@f3c6f9f95723 /]#   删除容器\n1 2  C:\\WINDOWS\\system32\u0026gt;docker rm a7f a7f   删除镜像\n1  docker rmi   "},{"id":14,"href":"/post/%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/","title":"穷举搜索","section":"Posts","content":"实质是创建一个状态树，边建立边剪枝，得到最终状态输出 步骤有：\n 列出表示状态的数据结构 列出在状态之间迁移的动作的数据结构 列出两个状态转换的所有动作列表 创建一个deque存储搜索的状态 从deque尾端取出状态，判断是否是最终状态，是的话打印当前deque，进行搜索search，循环所有动作，执行动作searchOnOneAction 判断新状态是否有效，有效则加入deque，继续递归调用搜索  有很多问题用到穷举搜索，比如过河问题\n 三个和尚和三个妖怪过河 船只能载两个 任何时候只要妖怪数量大于和尚数量 妖怪就要吃掉和尚 求解过河方案\n 这个问题首先确定状态的数据结构，状态就是两岸monk和monster的数量，同时有一些配套操作\n 判断是否是最终状态 状态迁移 判断状态是否有效  1 2 3 4 5 6 7 8 9 10 11 12 13  class ItemState{ friend\tostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp;, const ItemState\u0026amp;); public: bool operator==(const ItemState\u0026amp;); bool isFinalState(); bool takeAction(ItemState\u0026amp; next, const ACTION_EFFECTION\u0026amp; action); bool isValid(); int local_monster; int local_monk; int remote_monster; int remote_monk; BOAT_LOCATION boat; };   动作有如下定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  typedef enum{ ONE_MONSTER_GO = 0, TWO_MONSTER_GO, ONE_MONK_GO, TWO_MONK_GO, ONR_MONSTER_ONE_MONK_GO, ONE_MONSTER_BACK, TWO_MONSTER_BACK, ONE_MONK_BACK, TWO_MONK_BACK, ONR_MONSTER_ONE_MONK_BACK, INVALID_ACTION_NAME, }ACTION_NAME;\ttypedef struct{ ACTION_NAME act; BOAT_LOCATION boat_to; int move_monster; int move_monk; }ACTION_EFFECTION;   得到action的列表，作为穷举的依据\n1 2 3 4 5 6 7 8 9 10 11 12 13  static ACTION_EFFECTION actEffect[] = { {ONE_MONSTER_GO, REMOTE, -1, 0}, {TWO_MONSTER_GO, REMOTE,\t-2,\t0}, {ONE_MONK_GO,\tREMOTE,\t0,\t-1}, {TWO_MONK_GO,\tREMOTE,\t0,\t-2}, {ONR_MONSTER_ONE_MONK_GO,\tREMOTE,\t-1,\t-1}, {ONE_MONSTER_BACK,\tLOCAL,\t1,\t0}, {TWO_MONSTER_BACK,\tLOCAL,\t2,\t0}, {ONE_MONK_BACK,\tLOCAL,\t0,\t1}, {TWO_MONK_BACK,\tLOCAL,\t0,\t2}, {ONR_MONSTER_ONE_MONK_BACK,\tLOCAL,\t1,\t1} };   搜索时\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  void searchState(deque\u0026lt;ItemState\u0026gt; \u0026amp;states) { int act; ItemState current = states.back(); if(current.isFinalState()) { printResult(states); return; } for(act = 0; act \u0026lt; INVALID_ACTION_NAME; act++) { //debug_out \u0026lt;\u0026lt; act \u0026lt;\u0026lt;endl; \tsearchStateOnOneAction(states, current, actEffect[act]); } } void searchStateOnOneAction(deque\u0026lt;ItemState\u0026gt; \u0026amp;states, ItemState \u0026amp;current, ACTION_EFFECTION\u0026amp; actEff) { ItemState next; bool canTackAction; canTackAction = current.takeAction(next, actEff); //debug_out \u0026lt;\u0026lt; next; \tif(canTackAction \u0026amp;\u0026amp; !isProcessed(states, next)) { //debug_out \u0026lt;\u0026lt; \u0026#34;valid\u0026#34; \u0026lt;\u0026lt; endl; \t// printResult(states); \tstates.push_back(next); searchState(states); states.pop_back(); } }   两个函数起到了递归的作用，同时使用deque避免出现环路\n1 2 3 4 5 6  bool isProcessed(deque\u0026lt;ItemState\u0026gt; \u0026amp;states, ItemState\u0026amp; state) { auto it = states.end(); it = find_if(states.begin(), states.end(), [\u0026amp;](ItemState\u0026amp; s){return s==state;}); return(it!=states.end()); }   完整代码见https://github.com/lclei/algorithm_fun/tree/master/MonkAndMonster\n最后的找到了四种方案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195  o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 3o || 0o 1x || 2x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 0o || 3o 2x || 1x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 3o || 0o 1x || 2x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 1o || 2o 1x || 2x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 2o || 1o 2x || 1x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 0o || 3o 2x || 1x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 2o || 1o 2x || 1x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 1o || 2o 1x || 2x boat|| 0o || 3o 0x || 3x ||boat   "},{"id":15,"href":"/post/wbcurrency/","title":"并发服务器","section":"Posts","content":" fork进程 IO复用 线程   多进程 #  主进程监听，在循环中接受连接请求，当连接建立后，fork一个子进程，在子进程中进行处理。\n  主进程：listen -\u0026gt; while(1) -\u0026gt; accept -\u0026gt; fork -\u0026gt; close connfd\n  子进程：close listenfd -\u0026gt; handle -\u0026gt; close connfd\n  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverfork 6667 Parent: waitting\u0026hellip; name[localhost] port[38276]connected! Child No.1 will handle it! Parent: waitting\u0026hellip; server recived 6 bytes name[localhost] port[38280]connected! Child No.2 will handle it! Parent: waitting\u0026hellip; server recived 7 bytes\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 first first\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 second second\n code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void echo(int connfd); void sigchld_handler(int sig) { while(waitpid(-1,0,WNOHANG) \u0026gt;0) ; return; } int main(int argc, char **argv) { int listenfd, connfd, cno=1; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } signal(SIGCHLD, sigchld_handler); listenfd = open_listenfd(argv[1]); while(1){ printf(\u0026#34;Parent: waitting...\\n\u0026#34;); clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); printf(\u0026#34;name[%s] port[%s]connected! Child No.%d will handle it!\\n\u0026#34;, client_hostname,client_port,cno++); if(fork()==0) //child \t{ close(listenfd); echo(connfd); close(connfd); exit(0); } close(connfd); } exit(0); } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes\\n\u0026#34;,(int)n); write(connfd,buf,n); } } © 2019 GitHub, Inc.    IO复用 #  IO复用即使用select函数\n #include \u0026lt;sys/select.h\u0026gt; int select(int n, fd_set *fdset, NULL, NULL, NULL) //等待一组描述符准备好读 FD_ZERO(fd_set *fdset); FD_CLR(int fd, fd_set *fdset); FD_SET(int fd, fd_set *fdset); FD_ISSET(int fd, fd_set *fdset);\n stdio与connfd的复用 #  如果使用echoserver迭代版本的同时，要求能够响应服务器本身的stdin输入，则可以使用select。一个标准输入的fd一般是0，监听fd则是系统分配\n 将stdin和llistenfd加入fdset 使用select等待是否有fd准备好 通过FD_ISSET查看哪个准备好并进行相应的处理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void echo(int connfd); void command(void); int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; fd_set read_set, ready_set; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); FD_ZERO(\u0026amp;read_set);\t//clear read_set \tFD_SET(STDIN_FILENO, \u0026amp;read_set);\t//add stdin to read_set \tFD_SET(listenfd,\u0026amp;read_set);\t//add listenfd to read_set  while(1){ ready_set = read_set; select(listenfd+1,\u0026amp;ready_set,NULL,NULL,NULL); if(FD_ISSET(STDIN_FILENO,\u0026amp;ready_set)) { printf(\u0026#34;stdin is ready.\\n\u0026#34;); command(); } if(FD_ISSET(listenfd,\u0026amp;ready_set)){ printf(\u0026#34;client connetted.\\n\u0026#34;); clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); echo(connfd); close(connfd); } } exit(0); } void command(void){ char buf[MAXLINE]; if(!fgets(buf,MAXLINE,stdin)){ exit(0);\t//EOF \t} printf(\u0026#34;%s\u0026#34;,buf); } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes\\n\u0026#34;,(int)n); write(connfd,buf,n); } }   server behavior:\n [root@linuxkit-00155ddc0103 inet]# ./select 6667 do something stdin is ready. do something hello stdin is ready. hello client connetted. server recived 12 bytes ccd //no response here becuse client is connecting stdin is ready. //client close now ccd f stdin is ready. f stdin is ready. //ctrl+D here\n client behavior:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 i am client i am client\n 基于I/O多路复用的并发事件驱动器 #  与之前类似，维护一个结构体pool，存储readset，readyset和clientfd\n server监听，初始化pool 进入循环，初始化readyset，select阻塞，等待fd准备好 若listenfd，添加client 对所有准备好的clientfd回射服务  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverselect 6667 localhost:38334 connected! Server recived 5 (5 total) bytes on fd 4 Server recived 4 (9 total) bytes on fd 4 Server recived 7 (16 total) bytes on fd 4 localhost:38338 connected! Server recived 4 (20 total) bytes on fd 5 Server recived 6 (26 total) bytes on fd 5 Server recived 2 (28 total) bytes on fd 5 Close connfd 4 Server recived 7 (35 total) bytes on fd 5 Close connfd 5\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 1234 1234 123 123 123456 123456 [root@linuxkit-00155ddc0103 inet]#\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 123 123 12345 12345 1 1 123456 123456 [root@linuxkit-00155ddc0103 inet]#\n code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026#34;mynet.h\u0026#34;typedef struct{ int maxfd; fd_set read_set; fd_set ready_set; int nready; int maxi; int clientfd[FD_SETSIZE]; }pool; void add_client(int connfd, pool *p); void check_clients(pool *p); void init_pool(int listenfd, pool *p); int open_listenfd(char *port); int byte_cnt = 0; int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; static pool pool; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); init_pool(listenfd,\u0026amp;pool); while(1){ pool.ready_set = pool.read_set; pool.nready = select(pool.maxfd+1,\u0026amp;pool.ready_set,NULL,NULL,NULL); if(FD_ISSET(listenfd,\u0026amp;pool.ready_set)) { clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); printf(\u0026#34;%s:%s connected!\\n\u0026#34;,client_hostname,client_port); add_client(connfd, \u0026amp;pool); } check_clients(\u0026amp;pool); } exit(0); } void init_pool(int listenfd, pool *p){ int i; p-\u0026gt;maxi = -1; for(i=0;i\u0026lt;FD_SETSIZE;i++) p-\u0026gt;clientfd[i] = -1; p-\u0026gt;maxfd = listenfd; FD_ZERO(\u0026amp;p -\u0026gt; read_set); FD_SET(listenfd, \u0026amp;p-\u0026gt;read_set); } void add_client(int connfd, pool *p){ int i; p-\u0026gt;nready--; for(i=0;i\u0026lt;FD_SETSIZE;i++){ if(p-\u0026gt;clientfd[i]\u0026lt;0){ p-\u0026gt;clientfd[i] = connfd; FD_SET(connfd,\u0026amp;p-\u0026gt;read_set); if(connfd,\u0026amp;p-\u0026gt;maxfd) p-\u0026gt;maxfd = connfd; if(i\u0026gt;p-\u0026gt;maxi) p-\u0026gt;maxi = i; break; } if(i == FD_SETSIZE) printf(\u0026#34;Add client error! Beyond max client numbers.\\n\u0026#34;); } } void check_clients(pool *p) { int i,connfd,n; char buf[MAXLINE]; char echostr[MAXLINE+10]; for(i=0;(i\u0026lt;=p-\u0026gt;maxi)\u0026amp;\u0026amp;(p-\u0026gt;nready\u0026gt;0);i++){ connfd = p-\u0026gt;clientfd[i]; sprintf(buf,\u0026#34;\\0\u0026#34;); if((connfd\u0026gt;0)\u0026amp;\u0026amp;(FD_ISSET(connfd,\u0026amp;p-\u0026gt;ready_set))){ p-\u0026gt;nready--; if((n=read(connfd,buf,MAXLINE))!=0){ byte_cnt+=n; printf(\u0026#34;Server recived %d (%d total) bytes on fd %d\\n\u0026#34;,n,byte_cnt,connfd); write(connfd,buf,n); } else{ printf(\u0026#34;Close connfd %d\\n\u0026#34;,connfd); close(connfd); FD_CLR(connfd,\u0026amp;p-\u0026gt;read_set); p-\u0026gt;clientfd[i] = -1; } } } }    多线程 #  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverthread 6667 name[localhost] port[38362]connected! Thread id:140562122241792 will serve it! name[localhost] port[38366]connected! Thread id:140562113849088 will serve it! server recived 6 bytes from fd 4 server recived 4 bytes from fd 4 server recived 7 bytes from fd 5 server recived 4 bytes from fd 5\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667\n12345 12345 123 123\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 654321 654321 321 321\n 注意传递connfd时是新申请空间，并在thread里释放 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void *thread(void *vargp); void echo(int connfd); int main(int argc, char **argv) { int listenfd, *connfdp, cno=1; socklen_t clientlen; pthread_t tid; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); while(1){ clientlen = sizeof(struct sockaddr_storage); connfdp = malloc(sizeof(int)); *connfdp = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); pthread_create(\u0026amp;tid,NULL,thread,connfdp); printf(\u0026#34;name[%s] port[%s]connected! Thread id:%ld will serve it!\\n\u0026#34;, client_hostname,client_port,(unsigned long long)tid); } exit(0); } void *thread(void* vargp){ int connfd = *((int *)vargp); pthread_detach(pthread_self()); free(vargp); echo(connfd); close(connfd); return NULL; } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes from fd %d\\n\u0026#34;,(int)n,connfd); write(connfd,buf,n); } }   基于线程的事件驱动程序 #  也称作预线程化的方法\n 主线程将连接符connfd放入池中 工作线程将connfd取出并处理 加入线程和取出线程都使用互斥量保护 echo程序中的cnt也使用互斥量保护  server\n [root@linuxkit-00155ddc0103 inet]# ./echoserver_pre_thread 6667 client[localhost:38376] connected! connfd 4! server recived 7 (7 total) bytes on fd 4 client[localhost:38380] connected! connfd 5! server recived 9 (16 total) bytes on fd 5 server recived 4 (20 total) bytes on fd 4\n client1\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 123456 123456 123 123\n client2\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 87654321 87654321\n sbuf.c fd池，插入，取出操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026#34;sbuf.h\u0026#34; void sbuf_init(sbuf_t *sp, int n){ sp-\u0026gt;buf = calloc(n, sizeof(int)); sp-\u0026gt;n = n; sp-\u0026gt;front = sp-\u0026gt;rear = 0; sem_init(\u0026amp;sp-\u0026gt;mutex,0,1); sem_init(\u0026amp;sp-\u0026gt;slots,0,n); sem_init(\u0026amp;sp-\u0026gt;items,0,0); } void snuf_deinit(sbuf_t *sp){ free(sp-\u0026gt;buf); } void sbuf_insert(sbuf_t *sp, int item){ sem_wait(\u0026amp;sp-\u0026gt;slots); sem_wait(\u0026amp;sp-\u0026gt;mutex); sp-\u0026gt;buf[(++sp-\u0026gt;rear)%(sp-\u0026gt;n)] = item; sem_post(\u0026amp;sp-\u0026gt;mutex); sem_post(\u0026amp;sp-\u0026gt;items); } int sbuf_remove(sbuf_t *sp){ int item; sem_wait(\u0026amp;sp-\u0026gt;items); sem_wait(\u0026amp;sp-\u0026gt;mutex); item = sp-\u0026gt;buf[(++sp-\u0026gt;front)%(sp-\u0026gt;n)]; sem_post(\u0026amp;sp-\u0026gt;mutex); sem_post(\u0026amp;sp-\u0026gt;slots); return item; }   sbuf结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #ifndef SBUF_H_ #define SBUF_H_ #include \u0026#34;mynet.h\u0026#34;#include \u0026lt;semaphore.h\u0026gt; typedef struct { int *buf; int n; int front; int rear; sem_t mutex; sem_t slots; sem_t items; }sbuf_t; void dbuf_init(sbuf_t *sp, int n); void sbuf_deinit(sbuf_t *p); void sbuf_insert(sbuf_t *sp, int item); int sbuf_remove(sbuf_t *sp); #endif   echo_cnt.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026#34;echo_cnt.h\u0026#34; static int byte_cnt; static sem_t mutex; static void init_echo_cnt(void){ sem_init(\u0026amp;mutex,0,1); byte_cnt = 0; } void echo_cnt(int connfd){ int n; char buf[MAXLINE]; static pthread_once_t once = PTHREAD_ONCE_INIT; pthread_once(\u0026amp;once, init_echo_cnt); while((n=read(connfd,buf,MAXLINE))!=0){ sem_wait(\u0026amp;mutex); byte_cnt += n; printf(\u0026#34;server recived %d (%d total) bytes on fd %d\\n\u0026#34;, n,byte_cnt,connfd); sem_post(\u0026amp;mutex); write(connfd,buf,n); } }   主程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include \u0026#34;mynet.h\u0026#34;#include \u0026#34;sbuf.h\u0026#34;#include \u0026#34;echo_cnt.h\u0026#34;#define NTHREADS 4 #define SBUFSIZE 16  int open_listenfd(char *port); void *thread(void *vargp); sbuf_t sbuf; int main(int argc, char **argv) { int listenfd, connfd, i; socklen_t clientlen; pthread_t tid; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); sbuf_init(\u0026amp;sbuf,SBUFSIZE); for(i = 0;i\u0026lt;NTHREADS;i++){ pthread_create(\u0026amp;tid,NULL,thread,NULL); } while(1){ clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); sbuf_insert(\u0026amp;sbuf,connfd); printf(\u0026#34;client[%s:%s] connected! connfd %d!\\n\u0026#34;, client_hostname,client_port,(int)connfd); } exit(0); } void *thread(void* vargp){ pthread_detach(pthread_self()); while(1){ int connfd = sbuf_remove(\u0026amp;sbuf); echo_cnt(connfd); close(connfd); } return NULL; }   "},{"id":16,"href":"/post/webserver/","title":"web服务器","section":"Posts","content":"首先创建几个函数以方便我们调用\n open_clinetfd: 创建一个网络socket，作为客户端，并且尝试连接主机 open_listenfd: 创建socket，作为主机，并开始监听  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026#34;mynet.h\u0026#34; int open_clientfd(char *hostname, char *port){ int clientfd; struct addrinfo hints, *listp, *p; memset(\u0026amp;hints, 0,sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_NUMERICSERV; hints.ai_flags |= AI_ADDRCONFIG; getaddrinfo(hostname, port, \u0026amp;hints, \u0026amp;listp); for(p=listp;p;p=p-\u0026gt;ai_next){ if((clientfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype,p-\u0026gt;ai_protocol))\u0026lt;0) continue; if(connect(clientfd,p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen)!=-1) break; close(clientfd); } freeaddrinfo(listp); if(!p) return -1; else return clientfd; } int open_listenfd(char *port) { struct addrinfo hints, *listp, *p; int listenfd, optval=1; memset(\u0026amp;hints, 0 ,sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; hints.ai_flags |= AI_NUMERICSERV; getaddrinfo(NULL, port, \u0026amp;hints, \u0026amp;listp); for(p=listp;p;p=p-\u0026gt;ai_next){ if((listenfd = socket(p-\u0026gt;ai_family,p-\u0026gt;ai_socktype,p-\u0026gt;ai_protocol)) \u0026lt; 0) continue; setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,(const void *)\u0026amp;optval,sizeof(int)); if(bind(listenfd,p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen)==0) break; //success \tclose(listenfd); //bind fail, try next \t} freeaddrinfo(listp); if(!p) return -1; if(listen(listenfd,LISTENQ)\u0026lt;0){ close(listenfd); return -1; } return listenfd; }   我们的服务器有以下几个模块\n int main(int argc, char** argv)：从shell读取参数作为端口，使用上述open_listenfd创建一个监听端口，使用accept创建一个连接，进入do_it开始处理事务 void doit(int fd)：do_it的参数是connfd，读取请求，调用parse_uri分析请求是静态请求还是动态请求，分别调用serve_static和serve_dynamic进行响应 int parse_uri(char *uri, char *filename, char *cgiargs)：url不包含cgi-bin则认为是静态请求，读取请求的文件，若没有，默认返回home.html；否则认为是动态请求 void serve_static(int fd, char *filename, int filesize)：发送header，再发送文件 void serve_dynamic(int fd, char *filename, char *cgiargs)：服务动态内容，在cgi-bin找运行程序  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173  #include \u0026#34;mynet.h\u0026#34; void doit(int fd); void read_requesthdrs(int fd); int parse_uri(char *uri, char *filename, char *cgiargs); void serve_static(int fd, char *filename, int filesize); void get_filetype(char *filename, char *filetype); void serve_dynamic(int fd, char *filename, char *cgiargs); void clienterror(int fd, char*cause, char *errnum, char *shortmsg, char *longmsg); int main(int argc, char** argv) { int listenfd,connfd; char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; if(argc!=2){ fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(1); } listenfd = open_listenfd(argv[1]); while(1){ clientlen = sizeof(clientaddr); connfd = accept(listenfd,(SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,0); printf(\u0026#34;Accepted connection from (%s, %s)\\n\u0026#34;,hostname,port); doit(connfd); close(connfd); } } void doit(int fd){ int is_static; struct stat sbuf; char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE]; char filename[MAXLINE], cgiargs[MAXLINE]; read(fd, buf, MAXLINE); printf(\u0026#34;Requset hears:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;,buf); sscanf(buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); if(strcasecmp(method, \u0026#34;GET\u0026#34;)){ clienterror(fd, method, \u0026#34;501\u0026#34;, \u0026#34;Not implementedd\u0026#34;,\u0026#34;Tiny does not implement this method\u0026#34;); return; } //read_requesthdrs(fd); \tis_static = parse_uri(uri,filename,cgiargs); if(stat(filename,\u0026amp;sbuf)\u0026lt;0){ clienterror(fd, filename, \u0026#34;404\u0026#34;, \u0026#34;Not found\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t find this file\u0026#34;); return; } if(is_static){ if(!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR \u0026amp; sbuf.st_mode)){ clienterror(fd, filename, \u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t read the file\u0026#34;); return; } serve_static(fd,filename,sbuf.st_size); } else { if(!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR \u0026amp; sbuf.st_mode)){ clienterror(fd, filename, \u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t run the CGI program\u0026#34;); return; } serve_dynamic(fd,filename,cgiargs); } } void read_requesthdrs(int fd){ char buf[MAXLINE]; read(fd,buf,MAXLINE); while(strcmp(buf, \u0026#34;\\r\\n\u0026#34;)){ read(fd,buf,MAXLINE); printf(\u0026#34;%s\u0026#34;,buf); } return; } int parse_uri(char *uri, char *filename, char *cgiargs){ char *ptr; if(!strstr(uri, \u0026#34;cgi-bin\u0026#34;)) { strcpy(cgiargs,\u0026#34;\u0026#34;); strcpy(filename,\u0026#34;.\u0026#34;); strcat(filename,uri); if(uri[strlen(uri)-1] == \u0026#39;/\u0026#39;) strcat(filename,\u0026#34;home.html\u0026#34;); return 1; } else{\t//dynammic content \tptr = index(uri,\u0026#39;?\u0026#39;); if (ptr) { strcpy(cgiargs, ptr+1); *ptr = \u0026#39;\\0\u0026#39;; } else strcpy(cgiargs, ptr+1); strcpy(filename,\u0026#34;.\u0026#34;); strcat(filename,uri); return 0; } } void serve_static(int fd, char *filename, int filesize){ int srcfd; char *srcp, filetype[MAXLINE], buf[MAXLINE*10]; get_filetype(filename, filetype); sprintf(buf, \u0026#34;HTTP/1.0 200 OK\\r\\n\u0026#34;); sprintf(buf, \u0026#34;%sServer: Tiny Web Server\\r\\n\u0026#34;,buf); sprintf(buf, \u0026#34;%sConnection: close\\r\\n\u0026#34;,buf); sprintf(buf, \u0026#34;%sContent-length: %d\\r\\n\u0026#34;,buf,filesize); sprintf(buf, \u0026#34;%sContent-type: %s\\r\\n\\r\\n\u0026#34;,buf,filetype); write(fd,buf,strlen(buf)); printf(\u0026#34;Response headers:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;,buf); srcfd = open(filename,O_RDONLY, 0); srcp = mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); close(srcfd); write(fd,srcp,filesize); munmap(srcp,filesize); } void get_filetype(char *filename, char *filetype){ if(strstr(filename,\u0026#34;.html\u0026#34;)) strcpy(filetype, \u0026#34;text/html\u0026#34;); else if (strstr(filename,\u0026#34;.gif\u0026#34;)) strcpy(filetype, \u0026#34;image/gif\u0026#34;); else if (strstr(filename,\u0026#34;.png\u0026#34;)) strcpy(filetype, \u0026#34;image/png\u0026#34;); else if (strstr(filename,\u0026#34;.jpg\u0026#34;)) strcpy(filetype, \u0026#34;image/jpeg\u0026#34;); else strcpy(filetype, \u0026#34;image/plain\u0026#34;); } void serve_dynamic(int fd, char *filename, char *cgiargs){ char buf[MAXLINE],*emptylist[] = {NULL}; sprintf(buf,\u0026#34;HTTP/1.0 200 OK\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); sprintf(buf,\u0026#34;Server: Tiny Web Server\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); if(fork()==0) { setenv(\u0026#34;QUERY_STRING\u0026#34;,cgiargs,1); dup2(fd,STDOUT_FILENO); execve(filename,emptylist,environ); } wait(NULL); } void clienterror(int fd, char*cause, char *errnum, char *shortmsg, char *longmsg){ char buf[MAXLINE], body[100*MAXLINE]; sprintf(body,\u0026#34;\u0026lt;html\u0026gt;\u0026lt;title\u0026gt;Tiny Error\u0026lt;/title\u0026gt;\u0026#34;); sprintf(body,\u0026#34;%s\u0026lt;body bgcolor=\u0026#34;\u0026#34;ffffff\u0026#34;\u0026#34;\u0026gt;\\r\\n\u0026#34;,body); sprintf(body,\u0026#34;%s%s: %s\\r\\n\u0026#34;,body,errnum,shortmsg); sprintf(body,\u0026#34;%s\u0026lt;p\u0026gt;%s: %s\\r\\n\u0026#34;,body,longmsg,cause); sprintf(body,\u0026#34;%s\u0026lt;hr\u0026gt;\u0026lt;em\u0026gt;The Tiny Web server\u0026lt;/em\u0026gt;\\r\\n\u0026#34;,body); sprintf(buf, \u0026#34;HTTP/1.0 %s %s\\r\\n\u0026#34;,errnum,shortmsg); write(fd,buf,strlen(buf)); sprintf(buf, \u0026#34;Content-type: text/html\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); sprintf(buf, \u0026#34;Content-length: %d\\r\\n\\r\\n\u0026#34;,(int)strlen(body)); write(fd,buf,strlen(buf)); write(fd,body,strlen(body)); }   "},{"id":17,"href":"/post/daemon/","title":"守护进程","section":"Posts","content":"守护进程 #   生存期长，常常在系统引导装入时启动，仅在系统关闭时终止 没有控制终端  如何编写 #   umask(0) 调用fork，使父进程exit setsid创建一个新会话 工作目录改为根目录 关闭不需要的文件描述符 关闭标准输入输出  实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026#34;apue.h\u0026#34;#include \u0026lt;syslog.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;sys/resource.h\u0026gt; void deamonize(const char *cmd){ int i, fd0, fd1, fd2; pid_t pid; struct rlimit rl; struct sigaction sa; // Clear file creation umask  umask(0); // Get maximum number of file descriptors  if (getrlimit(RLIMIT_NOFILE, \u0026amp;rl) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t get file limt\u0026#34;, cmd); // Become a session leader to lose controlling TTY  if( (pid=fork()) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t get file limit\u0026#34;, cmd); else if (pid != 0) // Parent  exit(0); setsid(); // Ensure future opens won\u0026#39;t allocate controlling TTYs  sa.sa_handler = SIG_IGN; sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = 0; if (sigaction(SIGHUP, \u0026amp;sa, NULL) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t ignore SIGHUP\u0026#34;, cmd); if ((pid = fork()) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t fork\u0026#34;, cmd); else if (pid != 0) exit(0); // Change the cuurent working directory to the root so  // we won\u0026#39;t prevent file systems from being unmounted.  if (chdir(\u0026#34;/\u0026#34;) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t change directory to /\u0026#34;, cmd); // Close all the file descriptors  if(rl.rlim_max == RLIM_INFINITY) rl.rlim_max = 1024; for(i = 0;i \u0026lt;rl.lim_max;i++) close(i); // Attach file descriptors 0, 1, 2 to /dev/ull  fd0 = open(\u0026#34;/dev/null\u0026#34;, O_RDWR); fd1 = dup(0); fd2 = dup(0); // Initiallize the log file  openlog(cmd, LOG_CONS, LOG_DAEMON); if(fd0!=0 || fd1 != 1 || fd2 != 2){ syslog(LOG_ERR, \u0026#34;unexpected file descriptors %d %d %d\u0026#34;, fd0, fd1, fd2); exit(1); } }   下面使用daemonize将main函数变为守护进程\n1 2 3 4 5  void daemonize(const char *cmd); int main(int argc, char **argv){ daemonize(\u0026#34;main\u0026#34;); sleep(110); }   查看执行结果\n1 2 3 4  lcl@FX50JK:~/Documents/hub/learning-record/linux/daemon$ ps -efj | grep ./main lcl 23738 1542 23737 23737 0 17:13 ? 00:00:00 ./main lcl 23744 6959 23743 6959 0 17:14 pts/1 00:00:00 grep --color=auto ./main   与一个正常非守护进程main1对比\n1 2 3 4  lcl@FX50JK:~/Documents/hub/learning-record/linux/daemon$ ps -efj | grep ./main UID PID PPID PGID SID C STIME TTY TIME CMD lcl 24079 1542 24078 24078 0 18:17 ? 00:00:00 ./main lcl 24089 2166 24089 2166 0 18:18 pts/0 00:00:00 ./main1   可见守护进程没有绑定终端，在孤儿进程组，不是会话首进程\n"},{"id":18,"href":"/post/thread3/","title":"线程同步2","section":"Posts","content":"线程同步2 #  时间锁\n1 2 3  #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;time.h\u0026gt; int pthread_mutex_timedlock(pthread_mutex_t * restrict mutex, const struct timespec *restrict tsptr);   愿意等待timespec描述的时间，达到时间返回错误码ETIMEOUT 一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // APUE example11-13 // pthread_mutex_timedlock // lcl 20190325 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;time.h\u0026gt;  int main (void) { int err; struct timespec tout; struct tm *tmp; char buf[64]; pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_lock(\u0026amp;lock); printf(\u0026#34;the mutex now is locked\\n\u0026#34;); clock_gettime(CLOCK_REALTIME, \u0026amp;tout); tmp = localtime(\u0026amp;tout.tv_sec); strftime(buf, sizeof(buf), \u0026#34;%r\u0026#34;, tmp); printf(\u0026#34;current time is %s\\n\u0026#34;,buf); tout.tv_sec += 10; err = pthread_mutex_timedlock(\u0026amp;lock,\u0026amp;tout); clock_gettime(CLOCK_REALTIME, \u0026amp;tout); tmp = localtime(\u0026amp;tout.tv_sec); strftime(buf,sizeof(buf), \u0026#34;%r\u0026#34;, tmp); printf(\u0026#34;the time is now %s\\n\u0026#34;,buf); if(err == 0) printf(\u0026#34;mutex locked again!\\n\u0026#34;); else printf(\u0026#34;can\u0026#39;t lock mutex again:%s\\n\u0026#34;,strerror(err)); exit(0); }   运行结果：\n1 2 3 4  the mutex now is locked current time is 01:08:51 PM the time is now 01:09:01 PM can\u0026#39;t lock mutex again:Connection timed out   读写锁，三种状态读加锁、写加锁和不加锁\n1 2 3 4 5 6 7 8  #include \u0026lt;pthread.h\u0026gt;int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destory(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)   如上，函数名可以很好的反映函数的功能。\n 写锁阻塞其他加锁 读锁阻塞写锁但不阻塞读锁 写锁在阻塞时，不再响应其他读锁请求。 "},{"id":19,"href":"/post/thread4/","title":"线程同步3","section":"Posts","content":"线程同步3 #  使用条件变量进行线程同步\n1 2 3 4 5 6 7  #include \u0026lt;pthread.h\u0026gt;int pthread_cond_init(pthread_cond_t *restrict cond; const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // APUE example 11-15  // using mutex and cond  // lcl 20190326  //  #include \u0026#34;../myapue/h\u0026#34;  #include \u0026lt;pthread.h\u0026gt;  struct msg{ struct msg * m_next; /* ...*/ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_mag(void) { struct msg *mp; for(;;) { pthread_mutex_lock(\u0026amp;qlock); while(workq == NULL) pthread_cond_wait(\u0026amp;qready, \u0026amp;qlock); mp = workq; workq = mp -\u0026gt; m_next; phread_mutex_unlock(\u0026amp;qlock); /* noe process msg */ } } void enqueue_msg(struct msg *mp) { pthread_mutex_lock(\u0026amp;qlock); mp-\u0026gt;m_next = workq; workq = mp; pthread_mutex_unlock(\u0026amp;qlock); pthread_cond_signal(\u0026amp;qready); }   barrier，屏障\n1 2 3 4 5  int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count); int pthrerd_barrier_destroy(pthread_barrier_t *barrier); int pthread_barrier_wait(pthread_barruer_t *barrier);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  /* APUE example 11-16 * using barrier * lcl 20190326 * */ #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt;  #define NTHR 8 #define NUMNUM 8000000L #define TNUM (NUMNUM/NTHR)  long nums[NUMNUM]; long snums[NUMNUM]; pthread_barrier_t b; //extern int qsort(void *, size_t, size_t, // int (*)(const void*, const void *));  int complong(const void *arg1, const void *arg2) { long l1 = *(long *)arg1; long l2 = *(long *)arg2; if (l1 == l2) return 0; else if (l1 \u0026lt;l2) return -1; else return 1; } void *thr_fn(void *arg) { long idx = (long)arg; qsort(\u0026amp;nums[idx], TNUM, sizeof(long), complong); pthread_barrier_wait(\u0026amp;b); return ((void*)0); } void merge() { long idx[NTHR]; long i,minidx, sidx, num; for (i = 0;i\u0026lt;NTHR; i++) idx[i] = i*TNUM; for (sidx = 0;sidx \u0026lt; NUMNUM; sidx++){ num = LONG_MAX; for (i = 0; i\u0026lt;NTHR; i++){ if( (idx[i] \u0026lt; (i+1)*TNUM) \u0026amp;\u0026amp; (nums[idx[i]] \u0026lt; num)){ num = nums[idx[i]]; minidx = i; } } snums[sidx] = nums[idx[minidx]]; idx[minidx]++; } } int main() { unsigned long i; struct timeval start,end; long long startusec, endusec; double elapsed; int err; pthread_t tid; // create the initial set of numbers to sort.  srandom(1); for(i=0; i\u0026lt;NUMNUM; i++) { nums[i] = random(); } // create 8 threads to sort the numbers  gettimeofday(\u0026amp;start,NULL); pthread_barrier_init(\u0026amp;b, NULL, NTHR+1); for (i=0; i\u0026lt;NTHR; i++) { err = pthread_create(\u0026amp;tid,NULL,thr_fn,(void *)(i*TNUM)); if(err!=0) printf(\u0026#34;can\u0026#39;t create thread\u0026#34;); } pthread_barrier_wait(\u0026amp;b); merge(); gettimeofday(\u0026amp;end,NULL); startusec = start.tv_sec * 1000000 + start.tv_usec; endusec = end.tv_sec * 1000000 + end.tv_usec; elapsed = (double)(endusec - startusec)/1000000.0; printf(\u0026#34;sort using %.4f seconds\\n\u0026#34;,elapsed); for(i=0;i\u0026lt;100;i++) printf(\u0026#34;%ld\\n\u0026#34;,snums[i]); exit(0); }   "},{"id":20,"href":"/post/thread2/","title":"线程同步1","section":"Posts","content":"线程同步1 #  互斥量mutex\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;pthread,h\u0026gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); //对互斥量加锁，如果已经加锁，线程阻塞直至被解锁 int pthread_mutex_trylock(pthread_mutex_t *mutex); //如果已经加锁，不会阻塞，而是返回EBUSY int pthread_mutex_unlock(pthread_mutex_t *mutex);   下面的例子演示对一个对象进行引用计数。引用计数是受互斥量保护的，每回hold对象时，加锁，引用计数加一;release时，解锁，引用计数减一。例外情况是在初始化时，对象刚被创造，不需要加锁。以及对象最后一个引用释放时同时释放空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // APUE 11-10 // use mutex to protect data // lcl 20190324 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  struct foo { int f_count; pthread_mutex_t f_lock; int f_id; /* more stuff here */ }; struct foo* foo_alloc(int id) { struct foo * fp; if ((fp = malloc(sizeof(struct foo))) != NULL) { fp-\u0026gt;f_count = 1; fp-\u0026gt;f_id = id; if (pthread_mutex_init(\u0026amp;fp-\u0026gt;f_lock, NULL) != 0) { free(fp); return(NULL); } } return(fp); } void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } void foo_rele(struct foo * fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (--fp-\u0026gt;f_count == 0) { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_destory(\u0026amp;fp-\u0026gt;f_lock); free(fp); } else { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } }   避免死锁，使用两个互斥锁时，需要操作时指定加锁顺序，否则可能造成两个资源相互持有对方需要的锁，一直处于阻塞状态。下例中，既有保护对象的锁f_lock，也有对象所在的全局哈希表的锁hashlock，当同时使用两个锁时，每次操作都按照先锁hashlock再锁f_lock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  // APUE 11-11 // use two mutex to protect struct and hash // lcl 20190324 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  #define NHASH 29 #define HASH(id) (((unsigned long)id)%NHASH)  struct foo *fh[NHASH]; pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER; struct foo { int f_count; pthread_mutex_t f_lock; int f_id; /* more stuff here */ struct foo *f_next; }; struct foo* foo_alloc(int id) { struct foo * fp; int idx; if ((fp = malloc(sizeof(struct foo))) != NULL) { fp-\u0026gt;f_count = 1; fp-\u0026gt;f_id = id; if (pthread_mutex_init(\u0026amp;fp-\u0026gt;f_lock, NULL) != 0) { free(fp); return(NULL); } idx = HASH(id); pthread_mutex_lock(\u0026amp;hashlock); fp-\u0026gt;f_next = fh[idx]; fh[idx] = fp; pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_unlock(\u0026amp;hashlock); /* ... */ pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } return(fp); } void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } struct foo_find(int id) { struct foo *fp; pthread_mutex_lock(\u0026amp;hashlock); for (fp = fh[HASH(id)]; fp != NULL; fp = fp-\u0026gt;f_next){ if (fp-\u0026gt;f_id == id){ foo_hold(fp); break; } } pthread_mutex_unlock(\u0026amp;hashlock); return(fp); } void foo_rele(struct foo * fp) { struct foo *fp; int idx; pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (fp-\u0026gt;f_count == 1) { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_lock(\u0026amp;hashlock); pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (fp-\u0026gt;f_count != 1) { fp-\u0026gt;f_count--; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_unlock(\u0026amp;hashlock); return; } idx = HASH(fp-\u0026gt;f_id); tfp = fh[idx]; if(tfp == fp){ fh[idx] = fp -\u0026gt;f_next; } else { while(tfp-\u0026gt;next != fp) { tfp = tfp-\u0026gt;next; } tfp-\u0026gt;next = fp-\u0026gt;next; } pthread_mutex_unlock(\u0026amp;hashlock); pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_destory(\u0026amp;fp-\u0026gt;f_lock); free(fp); } else { fp-\u0026gt;f_count--; pthread_mutex_unlock(fp-\u0026gt;f_lock); } }   这样做的负担显而易见，尤其是release时，因为最后一个引用release时，需要删除，又需要操作哈希表，按照加锁顺序的要求，此时要先释放f_lock，再锁hashlock，再锁f_lock，而再这个过程中，其他线程可能又占用了该资源，需要重新检查计数。。\n若只使用hashlock来管理，则会变得简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;hashlock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;hashlock); } void foo_rele(struct foo * fp) { pthread_mutex_lock(\u0026amp;hashlock); if (--fp-\u0026gt;f_count == 0) { pthread_mutex_unlock(\u0026amp;hashlock); pthread_mutex_destory(\u0026amp;hashlock); free(fp); } else { pthread_mutex_unlock(\u0026amp;hashlock); } }   但是这样的锁太粗，容易造成多个线程等待同一把锁，影响性能。所以需要进行性能和复杂的平衡。\n"},{"id":21,"href":"/post/thread1/","title":"线程的创建及退出","section":"Posts","content":"线程的创建及退出 #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  1 // APUE example 11-2 2 // lcl 20190314 3 4 #include \u0026#34;../myapue.h\u0026#34; 5 #include \u0026lt;pthread.h\u0026gt; 6 7 pthread_t ntid; 8 9 void printids(const char *s) 10 { 11 pid_t pid; 12 pthread_t tid; 13 14 pid = getpid(); 15 tid = pthread_self(); 16 printf(\u0026#34;%s pid %lu tid %lu (0x%lx)\\n\u0026#34;,s,(unsigned long)pid,(unsigned long)tid,(unsigned long)tid); 17 } 18 19 void * thr_fn(void *arg) 20 { 21 printids(\u0026#34;new thread: \u0026#34;); 22 return ((void*)0); 23 } 24 25 int main (void) 26 { 27 int err; 28 err = pthread_create(\u0026amp;ntid, NULL, thr_fn, NULL); 29 if (err != 0) 30 printf(\u0026#34;can\u0026#39;t create thread\\n\u0026#34;); 31 printids(\u0026#34;main thread: \u0026#34;); 32 sleep(1); 33 exit(0); 34 }   编译时需要链接pthread，因为pthread不是标准库\n1 2 3 4  [root@f3c6f9f95723 ch11]# gcc pthr.c -lpthread -g -o pthr [root@f3c6f9f95723 ch11]# ./pthr main thread: pid 63 tid 140407368517440 (0x7fb323530740) new thread: pid 63 tid 140407360116480 (0x7fb322d2d700)   线程退出，接收退出码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  1 // APUE example 11-2 2 // lcl 20190304 3 4 #include \u0026#34;../myapue.h\u0026#34; 5 #include \u0026lt;pthread.h\u0026gt; 6 7 void *thr_fn1(void *arg) 8 { 9 printf(\u0026#34;thread 1 returning\\n\u0026#34;); 10 return ((void *) 1); 11 } 12 13 void *thr_fn2(void *arg) 14 { 15 printf(\u0026#34;thread 2 exiting\\n\u0026#34;); 16 pthread_exit((void *)2); 17 } 18 19 int main(void) 20 { 21 int err; 22 pthread_t tid1,tid2; 23 void *tret; 24 25 err = pthread_create(\u0026amp;tid1, NULL, thr_fn1, NULL); 26 if(err != 0) 27 printf(\u0026#34;err %d, can\u0026#39;t create thread 1\\n\u0026#34;,err); 28 err = pthread_create(\u0026amp;tid2, NULL, thr_fn2, NULL); 29 if (err != 0) 30 printf(\u0026#34;err %d, can\u0026#39;t create thread 2\\n\u0026#34;,err); 31 err = pthread_join(tid1, \u0026amp;tret); 32 if (err != 0) 33 printf(\u0026#34;err %d, can\u0026#39;t join with thread1\\n\u0026#34;,err); 34 printf(\u0026#34;thread 1 exit code %ld\\n\u0026#34;,(long)tret); 35 err = pthread_join(tid2, \u0026amp;tret); 36 if (err != 0) 37 printf(\u0026#34;err %d, can\u0026#39;t join with thread2\\n\u0026#34;,err); 38 printf(\u0026#34;thread 2 exit code %ld\\n\u0026#34;,(long)tret); 39 exit(0); 40 }   1 2 3 4 5 6  [root@f3c6f9f95723 ch11]# gcc get_exit_of_thread.c -g -lpthread -o get_exit_of_thread [root@f3c6f9f95723 ch11]# ./get_exit_of_thread thread 1 returning thread 1 exit code 1 thread 2 exiting thread 2 exit code 2   线程退出时返回地址，此地址在线程退出后被覆盖的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  // APUE example 11-4 // lcl 20190314 /****************************************** [root@f3c6f9f95723 ch11]# ./exit_thread_err structure at 0x7f33a3ce7f00 foo.a = 1 foo.b = 2 foo.c = 3 foo.d = 4 parent create a second thread: thread 2: ID is 139859768280832 structure at 0x7ffebf271120 foo.a = -1546748160 foo.b = 32563 foo.c = -1087952529 foo.d = 32766 ******************************************/ #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  struct foo { int a, b, c, d; }; void printfoo(const char *s, const struct foo *fp) { printf(\u0026#34;%\u0026#34;,s); printf(\u0026#34; structure at 0x%lx\\n\u0026#34;, (unsigned long)fp); printf(\u0026#34; foo.a = %d\\n\u0026#34;,fp-\u0026gt;a); printf(\u0026#34; foo.b = %d\\n\u0026#34;,fp-\u0026gt;b); printf(\u0026#34; foo.c = %d\\n\u0026#34;,fp-\u0026gt;c); printf(\u0026#34; foo.d = %d\\n\u0026#34;,fp-\u0026gt;d); } void *thr_fn1(void *arg) { struct foo foo1 = {1,2,3,4}; printfoo(\u0026#34;thread 1:\\n\u0026#34;, \u0026amp;foo1); pthread_exit((void*)\u0026amp;foo1); } void *thr_fn2(void *arg) { printf(\u0026#34;thread 2: ID is %lu\\n\u0026#34;,(unsigned long)pthread_self()); pthread_exit((void *)0); } int main(void) { int err; pthread_t tid1,tid2; struct foo *fp; err = pthread_create(\u0026amp;tid1, NULL, thr_fn1, NULL); if(err != 0) printf(\u0026#34;err %d, can\u0026#39;t create thread 1\\n\u0026#34;,err); err = pthread_join(tid1, (void*)fp); if (err != 0) printf(\u0026#34;err %d, can\u0026#39;t join with thread1\\n\u0026#34;,err); sleep(1); printf(\u0026#34;parent create a second thread:\\n\u0026#34;); err = pthread_create(\u0026amp;tid2, NULL, thr_fn2, NULL); if (err != 0) printf(\u0026#34;err %d, can\u0026#39;t create thread 2\\n\u0026#34;,err); sleep(1); printfoo(\u0026#34;parent:\\n\u0026#34;,fp); exit(0); }   "},{"id":22,"href":"/post/socket/","title":"socket编程","section":"Posts","content":"socket编程 #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXLINE 1024  int main(int argc, char **argv) { struct addrinfo *p,*listp, hints; char buf[MAXLINE]; int rc, flags; if(argc != 2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;domain niane\u0026gt;\\n\u0026#34;, argv[0]); exit(0); } //Get a list of addrinfo records  memset(\u0026amp;hints,0,sizeof(struct addrinfo)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; if((rc=getaddrinfo(argv[1],NULL,\u0026amp;hints,\u0026amp;listp))!=0){ //Get a list of addrinfo records  memset(\u0026amp;hints,0,sizeof(struct addrinfo)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; if((rc=getaddrinfo(argv[1],NULL,\u0026amp;hints,\u0026amp;listp))!=0){ fprintf(stderr, \u0026#34;getaddrinfo error: %s\\n\u0026#34;,gai_strerror(rc)); exit(1); } // Walk the list and display each IP address  flags = NI_NUMERICHOST; for(p=listp;p;p=p-\u0026gt;ai_next){ getnameinfo(p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen, buf, MAXLINE,NULL,0,flags); printf(\u0026#34;%s\\n\u0026#34;,buf); } freeaddrinfo(listp); exit(0); }   1 2 3 4 5  [root@f3c6f9f95723 inet]# ./hostinfo www.baidu.com 14.215.177.38 14.215.177.39 [root@f3c6f9f95723 inet]# ./hostinfo www.ustc.edu.cn 218.22.21.21   "},{"id":23,"href":"/post/lambda/","title":"lambda表达式","section":"Posts","content":"lambda表达式 #  介绍 #  一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。形式为\n1 2  [capture list](parameter list) -\u0026gt; return type { function body} //必须使用尾置返回   几个特点\n 必须使用尾置返回 在创建时捕获 只有一行return语句时可省略返回类型，否则默认为void 一般在给算法传递谓词时可以使用  lambda表达式的捕获 #   值捕获  1 2 3 4 5 6 7  void fun1() { size_t v1 = 21; auto f = [v1]{return v1;}; //省略了参数列表  v1 = 0; cout \u0026lt;\u0026lt; f(); }   输出21\n 引用捕获  1 2 3 4 5 6 7  void fun2() { size_t v2 = 21; auto f2 = [\u0026amp;v2] {return v2;}; v2 = 0; cout \u0026lt;\u0026lt; f2(); }   将输出0\n 隐式捕获 只在捕获列表里加=（值）或者\u0026amp;（引用），由编译器来推断  1 2 3 4 5 6 7  void fun3() { size_t v3 = 21; auto f3 = [\u0026amp;] {return v3;}; v3 = 0; cout \u0026lt;\u0026lt; f3(); }   输出0\n 混合捕获 即在捕获列表开始使用=或者\u0026amp;隐式捕获，再对不同的捕获变量使用显式捕获。此显式捕获必须与开始的隐式捕获不同（值或引用）  mutable #  对于值捕获，lambda表达式不能改变捕获的参数，如\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [=] (int i) {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   编译错误\n error: increment of read-only variable \u0026lsquo;v4\u0026rsquo;|\n 可以在参数列表后面加mutable，同时即使没有参数，参数列表也不能省略了。\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [=] (int i) mutable {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   而用引用捕获时就不需要了\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [\u0026amp;] (int i) {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   返回 #  当函数体不是只有一条return语句时需要指定返回类型，且必须用尾置返回类型。\n"},{"id":24,"href":"/post/allocator/","title":"allocator","section":"Posts","content":"allocator #   #include \u0026lt;memory\u0026gt;\n  allocator\u0026lt;T\u0026gt; a 定义一个名为a的allocator对象，它可以为类型为T的对象分配内存\n  a.allocate(n) 分配一段原始的、未构造的内存，保存n个类型为T的对象\n  a.deallocate(p,n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象，与a.allocate(n)对应\n  a.construct(p, args) p是指针，args是对象的构造函数，用来构造对象\n  a.destroy(p) 对p指向的对象执行析构函数\n "},{"id":25,"href":"/post/bind/","title":"bind","section":"Posts","content":"bind #   auto g = bind(f, arg_list)\n 用我自己的话来说，就是把原来函数f的参数重新安排，可以直接绑定值，也可以使用占位符placeholder，达到减少参数或者调换参数顺序的作用。\n例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;functional\u0026gt; using namespace std; using namespace std::placeholders; // for _1, _2 ...  string f(string a1, string a2, string a3, string a4) { return a1+a2+a3+a4; } int main(int argc, char *argv[]) { auto g = bind(f,_1,\u0026#34;Two\u0026#34;,\u0026#34;Three\u0026#34;,\u0026#34;Four\u0026#34;); cout \u0026lt;\u0026lt; g(\u0026#34;One\u0026#34;) \u0026lt;\u0026lt; endl; return 0; }   输出\n OneTwoThreeFour\n 这样就把一个四个参数的函数f(4)转成了一个参数的函数g(1)，其中的占位符_1表示g的第一个参数。\n如果交换参数的顺序，也是使用占位符，比如上例\n1 2 3 4 5 6  int main(int argc, char *argv[]) { auto g = bind(f,_4,_2,_3,_1); cout \u0026lt;\u0026lt; g(\u0026#34;One\u0026#34;,\u0026#34;Two\u0026#34;,\u0026#34;Three\u0026#34;,\u0026#34;Four\u0026#34;) \u0026lt;\u0026lt; endl; return 0; }   输出\n FourTwoThreeOne\n 所以占位符就是表示g中的第几个参数，再按顺序传给f。\n可以用于调整参数顺序，绑定部分参数等，做一个函数适配器的功能。\n"},{"id":26,"href":"/post/inserter/","title":"插入迭代器","section":"Posts","content":"插入迭代器 #  接受一个容器，生成一个迭代器，实现向给定容器插入元素\n操作 #   it = t\n 在it指定的当前位置插入值t，且根据插入迭代器的类型不同，分别调用c.push_back(t), c.oush_front(t), c.insert(t,p)\n *it, it++, ++it\n 有这些形式，但是什么都不做\n##类型\n  back_inserter 创建一个使用push_back的迭代器\n  front_inserter 创建一个使用push_front的迭代器\n  inserter 创建一个使用insert的迭代器 若it是一个inserter则以下代码\n  1  *it = val;   与\n1 2  it = c.insert(it, val); ++it;   效果一样 示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; void Output(const list\u0026lt;int\u0026gt; \u0026amp;a){ ostream_iterator\u0026lt;int\u0026gt; out_iter(cout,\u0026#34; \u0026#34;); copy(a.cbegin(),a.cend(),out_iter); cout \u0026lt;\u0026lt; endl; } int main(int argc, char *argv[]) { list\u0026lt;int\u0026gt;a1 = {1,2,3,4},a2,a3,a4; copy(a1.cbegin(),a1.cend(),inserter(a2,a2.begin())); copy(a1.cbegin(),a1.cend(),front_inserter(a3)); copy(a1.cbegin(),a1.cend(),back_inserter(a4)); Output(a2); Output(a3); Output(a4); }   输出\n 1 2 3 4 4 3 2 1 1 2 3 4\n"},{"id":27,"href":"/post/iostreamiterator/","title":"输入输出流迭代器","section":"Posts","content":"输入输出流迭代器 #  istream_iterator #   创建一个istream_iterator，然后把它绑定到一个流 如果默认初始化，则是一个尾后值的迭代器  ostream_iterator #  1 2  ostream_iterator\u0026lt;T\u0026gt; out(os) //out将类型为T的值写到os流中 ostream_iterator\u0026lt;T\u0026gt; out(os, d) //out将类型为T的值写到os流中，且在后面加上字符串d   有了输入输出流迭代器，我们可以把输入输出流当作容器来使用，在拷贝，初始化等等有和容器操作相同的形式，代码比较好看\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; int main(int argc, char* argv[]) { istream_iterator\u0026lt;int\u0026gt; in_iter(cin); istream_iterator\u0026lt;int\u0026gt; int_eof; vector\u0026lt;int\u0026gt; vec(in_iter,int_eof); //[1]  ostream_iterator\u0026lt;int\u0026gt; out_iter(cout,\u0026#34; \u0026#34;); copy(vec.cbegin(),vec.cend(),out_iter); //[2] }   该段代码接受屏幕输入，然后输出到屏幕，然后[1]和[2]都是容器使用迭代器的操作。比我们直接写循环显得简洁。\n"},{"id":28,"href":"/post/codewar1/","title":"codewar 题1","section":"Posts","content":"大数，阶乘，小数位数 #  在codewar的一道题\n Consider the following numbers (where n! is factorial(n)):\nu1 = (1 / 1!) * (1!) u2 = (1 / 2!) * (1! + 2!) u3 = (1 / 3!) * (1! + 2! + 3!) un = (1 / n!) * (1! + 2! + 3! + \u0026hellip; + n!) Which will win: 1 / n! or (1! + 2! + 3! + \u0026hellip; + n!)?\nAre these numbers going to 0 because of 1/n! or to infinity due to the sum of factorials or to another number?\nTask\nCalculate (1 / n!) * (1! + 2! + 3! + \u0026hellip; + n!) for a given n, where n is an integer greater or equal to 1.\nTo avoid discussions about rounding, return the result truncated to 6 decimal places, for example:\n1.0000989217538616 will be truncated to 1.000098\n1.2125000000000001 will be truncated to 1.2125\nRemark\nKeep in mind that factorials grow rather rapidly, and you need to handle large inputs.\n 一开始提交，连简单的测试的都过不了，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Suite { public: static double going(int n); }; long long f(int n){ if(n==1) return 1; else return (long long)(n*f(n-1)); } long long fa(int n){ if(n==1) return f(1); else return (long long)(f(n)+fa(n-1)); } double Suite::going(int n){ return result=((double)1.0)/f(n)*fa(n); }   给出这样的结果\n Test Results:\ngoing_Tests\nFixed__Tests\nExpected: equal to 1.2125\nActual: 1.2125\n 原因是浮点数不能直接比较，因此做了如下改进：\n1 2 3 4 5 6  double Suite::going(int n){ double result = ((double)1.0)/f(n)*fa(n); long long re_l = (long long)(result*1000000); result = ((double)re_l)/1000000.0; return result; }   现在的测试结果\n Test Results:\ngoing_Tests\nFixed__Tests\nLog\nCorrect. Testing; Expected is 1.275, and got 1.275\nCorrect. Testing; Expected is 1.2125, and got 1.2125\nCorrect. Testing; Expected is 1.173214, and got 1.173214\nCorrect. Testing; Expected is 1.146651, and got 1.146651\nCorrect. Testing; Expected is 1.052786, and got 1.052786\nTesting; Expected should be 1.034525, but got 0.68527\nExpected: false\nActual: 1\nRandom_tests\nLog\n****************** Random Tests **** going\nTesting; Expected should be 1.032292, but got 1.166542\nExpected: false\nActual: 1\n 很明显是阶乘结果太大，超出了long long的界限。\n20190401更： 原本想着使用大数的处理方法，如https://blog.csdn.net/qq_39445165/article/details/88377252\n但是发现即使使用了数组表示很大的数，后面的也不好处理。 现在把式子转化成1+1/n+1/n(n-1)+\u0026hellip;+1/n(n-1)\u0026hellip;2+1/n!，若分母很大比如大于10的8次方，那么这一项对于和没有意义，因为精度限制在六位小数，于是新的处理方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Suite { public: static double going(int n); }; double Suite::going(int n){ int i; long long re_l,temp = n; double result = 1.0; for(i=1;i\u0026lt;n;i++) { result += ((double)1.0)/temp; temp *= (n-i); if(temp\u0026gt;100000000) break; } re_l = (long long)(result*1000000); result = ((double)re_l)/1000000.0; return result; }   通过了测试\n"},{"id":29,"href":"/post/codewar2/","title":"CodeWar 题2","section":"Posts","content":"CodeWar::DoubleCola #  CodeWar上的一道题\n Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a \u0026ldquo;Double Cola\u0026rdquo; drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on.\nFor example, Penny drinks the third can of cola and the queue will look like this:\n Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny\n Write a program that will return the name of the person who will drink the n-th cola.\n 这种前端删除，double后加入后面，自然想到双向队列deque来做\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;deque\u0026gt;using namespace std; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { deque\u0026lt;string\u0026gt; q; string tmp; long long i; for(i=0;i\u0026lt;names.size();i++) q.push_back(names[i]); for(i=1;i\u0026lt;r;i++) { tmp = q[0]; q.pop_front(); q.push_back(tmp); q.push_back(tmp); } return q[0]; }   简单的测试能通过，但是最终测试显示超时，果然直接操作队列太慢了，尤其给的input范围\n 1 ≤ n ≤ 10000000000\n 所以还需要找到高效的方法， 考虑整个循环，人数每轮结束后为{5，10，20，40，。。。}，除以人数5之后就是一个二进制数{1,2,4,8,\u0026hellip;}，每一轮结束时的序号为{1,3,15,\u0026hellip;.}，因此我们只需要判断轮次。另外每一轮所处位置也可以通过右移得到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { r--; long long n = r/names.size(); long long d; long long i = 64; while(i\u0026gt;0){ i--; if(((n+1)\u0026amp;((long long)1\u0026lt;\u0026lt;i))\u0026gt;\u0026gt;i == 1) break; } d = r - (((long long)1\u0026lt;\u0026lt;i) - 1)*names.size(); return names[d\u0026gt;\u0026gt;i]; }   提交结果后看到的优秀解答：\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { long long x = r; while (x \u0026gt; names.size()) { x = (x - names.size() + 1) / 2; } return names[x-1]; }   "},{"id":30,"href":"/post/codewar3/","title":"codewar 题3","section":"Posts","content":"CodeWar::Intervals #   Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.\nIntervals\nIntervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.\nOverlapping Intervals\nList containing overlapping intervals:\n [ [1,4], [7, 10], [3, 5] ]\n The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.\nExamples:\n sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9\n  sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7\n  sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19\n  我的思路是\n 创建一个limits容器存储pair 对输入每一条pair检查是否与limits里的pair有重叠的地方，如果有，记录下位置存入overlap 将limits里对应的条目删去，在重合的条目中寻找最小的下限和最大的上限，插入limits中 最后计算intervals  我在自己的ide中运行正常，但是在codewars提交之后在某些情况下出错，code139，是越界之类的问题。 一开始我是用vector来存储limits的，由于涉及到删除元素的问题，特意还用overlap来记录迭代器，循环之后一起删除，经过排除还是发现删除元素后迭代器失效的问题，如上第3步。于是改用list。 这次的经历更深刻的告诉我要注意迭代器失效的问题。\n具体代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; limits,tmp; int tmpmin,tmpmax,res=0; vector\u0026lt;list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;::iterator\u0026gt; overlap; if(intervals.size() == 0) return 0; for(auto interval : intervals){ overlap.clear(); tmp.clear(); for(auto it = limits.begin();it!=limits.end();it++){ if((interval.first\u0026gt;=(*it).first \u0026amp;\u0026amp; interval.first\u0026lt;(*it).second) || (interval.second\u0026gt;(*it).first \u0026amp;\u0026amp; interval.second\u0026lt;=(*it).second) || (interval.first\u0026lt;=(*it).first \u0026amp;\u0026amp; interval.second\u0026gt;=(*it).second)){ overlap.push_back(it); tmp.push_back(*it); } } tmp.push_back(interval); if(overlap.size()!=0){ for(auto del_it : overlap) {limits.erase(del_it);} tmpmin=(*tmp.begin()).first; tmpmax=(*tmp.begin()).second; for(auto tmp_it = tmp.begin();tmp_it!=tmp.end();tmp_it++){ if(tmpmin\u0026gt;(*tmp_it).first) tmpmin = (*tmp_it).first; if(tmpmax\u0026lt;(*tmp_it).second) tmpmax =(*tmp_it).second; } limits.push_back(make_pair(tmpmin,tmpmax)); } else limits.push_back(interval); } for (auto limit:limits){ res+=(limit.second-limit.first); } return res; }   ·提交之后，欣赏一下其他人的解答：\n 使用了set的无重复性，统计区间内的所有整数，最后返回set的size。如果数的范围大的话，浪费内存，将两个数表示的区间，生成了非常多元素的set。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;unordered_set\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { std::unordered_set\u0026lt;int\u0026gt; ints; for (auto interv = intervals.begin(); interv != intervals.end(); ++interv){ for (int i = interv-\u0026gt;first; i \u0026lt; interv-\u0026gt;second; i++){ ints.insert(i); } } return ints.size(); }   先进行了排序，再维护一个max_right。即可计算结果。这个答案比较好。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; interavls) { sort(interavls.begin(), interavls.end()); int ret = 0; int max_right = interavls[0].first; for (auto \u0026amp;i : interavls) if (i.second \u0026gt;= max_right) { ret += i.second - std::max(max_right, i.first); max_right = i.second; } return ret; }   "},{"id":31,"href":"/post/codewar/","title":"CodeWars","section":"Posts","content":"codewars #  感觉题比leetcode的有趣，邀请链接 www.codewars.com/r/zuBfBg\n"},{"id":32,"href":"/post/hello-world/","title":"Hello World","section":"Posts","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start #  Create a new post #  1  $ hexo new \u0026#34;My New Post\u0026#34;   More info: Writing\nRun server #  1  $ hexo server   More info: Server\nGenerate static files #  1  $ hexo generate   More info: Generating\nDeploy to remote sites #  1  $ hexo deploy   More info: Deployment\n"}]