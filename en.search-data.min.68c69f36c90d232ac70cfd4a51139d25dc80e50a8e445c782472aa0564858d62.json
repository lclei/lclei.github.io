[{"id":0,"href":"/about/","title":"About","section":"lclei blog","content":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n"},{"id":1,"href":"/post/epoll/","title":"epollä¸ºä»€ä¹ˆæ¯”selecté«˜æ•ˆ","section":"Posts","content":"epollä»‹ç» #  epollæ˜¯linuxç»§selectå’Œpollä¹‹åçš„å¤šè·¯IOå¤ç”¨æ–¹å¼ã€‚å½“ç›‘å¬çš„fdå¤šäº†ä¹‹åï¼Œselectå’Œpolléƒ½æ˜¯è¦æŠŠæ‰€æœ‰çš„fdä»å¤´åˆ°å°¾éå†ä¸€éï¼Œå»æŸ¥è¯¢æ˜¯å¦æœ‰æ•°æ®åˆ°è¾¾ï¼Œè¿™æ ·éå¸¸ä½æ•ˆã€‚è€Œepollåœ¨å†…æ ¸ä¸­æŠŠç›‘å¬çš„fdç»„ç»‡ä¸ºçº¢é»‘æ ‘ï¼Œæ— ç–‘æé«˜äº†æŸ¥æ‰¾çš„æ•ˆç‡ã€‚ åœ¨åº”ç”¨æ—¶ï¼Œepollçš„æ¥å£å‡½æ•°ä¹Ÿå¾ˆç®€å•ï¼Œåªç”¨äº†ä¸‰ä¸ªæ¥å£ï¼š\n1 2 3  epoll_create1 epoll_ctl epill_wait   è‡ªå·±å†™äº†ä¸€ä¸ªdhcpå®¢æˆ·ç«¯çš„ä»¿çœŸå™¨ï¼Œå¸Œæœ›æ—¢æ¥å—ç»ˆç«¯çš„è¾“å…¥ï¼Œä¹Ÿæ¥æ”¶æœåŠ¡å™¨çš„æŠ¥æ–‡ã€‚ä½¿ç”¨epollæ˜¯è¿™æ ·ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #define MAX_EVENTS 2 int main() { struct Client client = {0}; if (-1 == init_client(\u0026amp;client)) { log_error(\u0026#34;Init client error, exit.\u0026#34;); return -1; } struct epoll_event ev, events[MAX_EVENTS]; int epollfd = epoll_create1(0); if (epollfd == -1) { perror(\u0026#34;epoll_create1\u0026#34;); return -1; } ev.events = EPOLLIN | EPOLLET; ev.data.fd = client.sock; epoll_ctl(epollfd, EPOLL_CTL_ADD, client.sock, \u0026amp;ev); ev.data.fd = STDIN_FILENO; epoll_ctl(epollfd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev); while (true) { int nfds = epoll_wait(epollfd, events, MAX_EVENTS, 1); for (int i = 0; i \u0026lt; nfds; ++i) { process_event(events[i].data.fd, \u0026amp;client); } } return 0; }   å’Œselectç”¨æ³•å…¶å®æ˜¯å·®ä¸å¤šçš„ã€‚äº‹å®ä¸Šï¼Œåœ¨redisçš„æºä»£ç ä¸­ï¼Œå°±æŠŠä»–ä»¬æ¥å£ç»Ÿä¸€ï¼Œä½œä¸ºaeä½¿ç”¨ï¼Œè§ae_epoll.cï¼Œae_select.cä¸¤ä¸ªæ–‡ä»¶ã€‚ åœ¨linuxå†…æ ¸ä¸­å®ç°ä¸º/fs/epoll.cã€‚å…³äºepollçš„å®ç°åŸç†ä»¥åŠä¸ºä»€ä¹ˆå¿«ï¼Œå‚è€ƒæ·±å…¥äº†è§£epollæ¨¡å‹ï¼Œè¿™ç¯‡æ–‡ç« å†™çš„æ¯”è¾ƒè¯¦ç»†ï¼Œè¿˜æœ‰åŸç†å›¾ç¤ºã€‚  epollå†…éƒ¨ä½¿ç”¨çº¢é»‘æ ‘ç»„ç»‡ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ï¼ŒæŸ¥æ‰¾é«˜æ•ˆã€‚ epollä½¿ç”¨å…±äº«å†…å­˜å‡å°‘æ–‡ä»¶æè¿°ç¬¦åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸ä¹‹é—´çš„æ‹·è´ã€‚  epollæ°´å¹³è§¦å‘å’Œè¾¹æ²¿è§¦å‘ #  ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/epoll.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define println(fmt, args...) printf(fmt\u0026#34;\\n\u0026#34;, ##args) #define MAX_EVENTS 2  static void read_fd(int fd) { char buf[9] = {0}; int sz = read(fd, buf, sizeof(buf) - 1); println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf); } int main(int argc, char **argv) { println(\u0026#34;epoll_create\u0026#34;); int efd = epoll_create1(0); if (efd == -1) { perror(\u0026#34;epoll_create1\u0026#34;); exit(0); } struct epoll_event events[2], ev; set_nonblock(STDIN_FILENO); println(\u0026#34;epoll_ctl\u0026#34;); ev.events = EPOLLIN; ev.data.fd = STDIN_FILENO; epoll_ctl(efd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev); while (true) { println(\u0026#34;epoll_wait...\u0026#34;); int nfds = epoll_wait(efd, events, MAX_EVENTS, -1); if (nfds == -1) { perror(\u0026#34;epoll_wait\u0026#34;); return -1; } if (nfds \u0026gt; 0) { println(\u0026#34;epoll_wait return %d\u0026#34;, nfds); for (int i = 0; i \u0026lt; nfds; ++i) { read_fd(events[i].data.fd); } } } return 0; }   æ¯æ¬¡æ•°æ®å°±ç»ªåï¼Œåªè¯»8ä¸ªå­—èŠ‚ï¼Œå½“è¾“å…¥123456789æ—¶ï¼š æ°´å¹³è§¦å‘ï¼š\n1 2 3 4 5 6 7 8 9 10 11  epoll_create epoll_ctl epoll_wait... 123456789 epoll_wait return 1 recv 8 bytes: 12345678 epoll_wait... epoll_wait return 1 recv 2 bytes: 9 epoll_wait...   è¾¹æ²¿è§¦å‘ï¼š\n1 2 3 4  println(\u0026#34;epoll_ctl\u0026#34;); ev.events = EPOLLIN | EPOLLET; ev.data.fd = STDIN_FILENO; epoll_ctl(efd, EPOLL_CTL_ADD, STDIN_FILENO, \u0026amp;ev);   å…¶è¾“å‡ºæ˜¯\n1 2 3 4 5 6 7  epoll_create epoll_ctl epoll_wait... 123456789 epoll_wait return 1 recv 8 bytes: 12345678 epoll_wait...   åªèƒ½è¯»å‡º8ä¸ªå­—èŠ‚ã€‚åé¢å°†ä¸ä¼šè‡ªåŠ¨è§¦å‘ï¼Œå³ä½¿æ²¡æœ‰è¯»å®Œæ•°æ®ã€‚å› æ­¤éœ€è¦è‡ªå·±ä¿è¯è¯»å–æ•°æ®å®Œæ•´ï¼Œå¦‚ä½¿ç”¨EAGAINåˆ¤æ–­ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13  static void read_fd(int fd) { // char buf[9] = {0};  // int sz = read(fd, buf, sizeof(buf) - 1);  // println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf);  while (true) { char buf[9] = {0}; int sz = read(fd, buf, sizeof(buf) - 1); if (sz == -1) { if (errno == EAGAIN) break; } println(\u0026#34;recv %d bytes: %s\u0026#34;, sz, buf); } }   reference: æ·±å…¥äº†è§£epollæ¨¡å‹ epollè¾¹ç¼˜è§¦å‘æ¨¡å¼\nç›¸å…³ï¼š [[muduo]] [[iouring]] [[select]]\n"},{"id":2,"href":"/post/fp_compare_cpp_rust/","title":"C++å‡½æ•°å¼ç¼–ç¨‹ä¸Rustå¯¹æ¯”","section":"Posts","content":"åœ¨åˆ·leetcodeçš„æ—¶å€™ï¼Œæƒ³ä½¿ç”¨c++20çš„èŒƒå›´åº“ï¼Œä½“éªŒä¸€ä¸‹å‡½æ•°å¼ç¼–ç¨‹çš„å¿«ä¹ã€‚è¿™ä¸€é¢˜æ˜¯leetcode 300é¢˜ã€‚\n300.Â Longest Increasing Subsequence Given an integer arrayÂ nums, returnÂ the length of the longestÂ strictly increasingÂ subsequence\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\nInput: nums = [0,1,0,3,2,3] Output: 4\nExample 3:\nInput: nums = [7,7,7,7,7,7,7] Output: 1\næœ‰ä¸¤ç§æ€è·¯æ¥åšï¼Œç°åœ¨ç”¨åŠ¨æ€è§„åˆ’çš„æ–¹æ³•å®ç°ï¼š dp[i]æ˜¯ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ï¼Œæ³¨æ„å¿…é¡»æ˜¯ä»¥nums[i]ç»“å°¾ï¼Œé‚£ä¹ˆé€’å½’å…¬å¼æ˜¯\n1  dp[i] = max(dp[j]) + 1 if nums[i] \u0026gt; nums[j] and i \u0026gt; j   åœ¨c++ä¸­ï¼Œä¸ºäº†è·å–ç´¢å¼•ï¼Œä½¿ç”¨äº†C++23çš„enumerateã€‚\n1 2 3 4 5 6 7 8  @startuml state dp dp -\u0026gt; dp1 : take i dp1 -\u0026gt; dp2 : enumerate dp2 -\u0026gt; dp3 : filter nums[i] \u0026gt; nums[j] dp3 -\u0026gt; dp4 : values dp4 -\u0026gt; max : max_element @enduml   codeå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;ranges\u0026gt; using namespace std; class Solution300 { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sz = nums.size(); // dp: LIS size of end with nums[i]  vector\u0026lt;int\u0026gt; dp(sz, 0); dp[0] = 1; for (int i = 1; i \u0026lt; sz; ++i) { // views::enumerate and views::values need c++23  auto v = dp | views::take(i) | views::enumerate | views::filter([\u0026amp;](auto item) {return nums[get\u0026lt;0\u0026gt;(item)] \u0026lt; nums[i];}) | views::values; dp[i] = v.empty() ? 1 : *ranges::max_element(v) + 1; } return *ranges::max_element(dp); } };   å…¶ä¸­å¯¹äºmax_elementï¼Œæœ¬æƒ³ç›´æ¥å†™æˆ\n1 2 3  dp[i] = *ranges::max_element(dp | views::take(i) | views::enumerate | views::filter([\u0026amp;](auto item) {return nums[get\u0026lt;0\u0026gt;(item)] \u0026lt; nums[i];}) | views::values) + 1;   ç„¶è€Œæœ‰ç¼–è¯‘å™¨æŠ¥é”™\n1 2 3 4 5  error: no match for \u0026#39;operator*\u0026#39; (operand type is \u0026#39;std::ranges::borrowed_iterator_t\u0026lt;std::ranges::filter_view\u0026lt;std::ranges::take_view\u0026lt;std::ranges::ref_view\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; \u0026gt;, Solution300::lengthOfLIS(std::vector\u0026lt;int\u0026gt;\u0026amp;)::\u0026lt;lambda(int)\u0026gt; \u0026gt; \u0026gt;\u0026#39;) 70 | *ranges::max_element(dp | views::take(i) | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 71 | | views::filter([\u0026amp;](int x) {return x \u0026lt; nums[i];})); | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   é”™è¯¯æ˜¾ç¤ºè¯¥ç±»å‹std::ranges::borrowed_iterator_tæ˜¯ä¸èƒ½è§£å¼•ç”¨çš„ã€‚ ä»cppreferenceç½‘ç«™ä¸ŠæŸ¥è¯¢åƒstd::ranges::max_elementï¼Œ std::ranges::lower_boundè¿™ä¸€ç±»çš„ç®—æ³•è¿”å›çš„éƒ½æ˜¯std::ranges::borrowed_iterator_tç±»å‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt; ranges::range R \u0026gt; using borrowed_iterator_t = /* see below */; è‹¥ R å®ç° borrowed_range åˆ™ä¸º std::ranges::iterator_t\u0026lt;R\u0026gt; ï¼Œå¦åˆ™ä¸º std::ranges::dangling ã€‚ æŸäº›å—çº¦æŸç®—æ³•ç”¨æ­¤äºŒæ¨¡æ¿åˆ«åé¿å…è¿”å›æ½œåœ¨æ‚¬å‚çš„è¿­ä»£å™¨æˆ–è§†å›¾ã€‚ template\u0026lt;class R\u0026gt; concept borrowed_range = ranges::range\u0026lt;R\u0026gt; \u0026amp;\u0026amp; (std::is_lvalue_reference_v\u0026lt;R\u0026gt; || ranges::enable_borrowed_range\u0026lt;std::remove_cvref_t\u0026lt;R\u0026gt;\u0026gt;); æ¦‚å¿µ borrowed_range å®šä¹‰èŒƒå›´çš„è¦æ±‚ï¼Œä½¿å¾—å‡½æ•°èƒ½æŒ‰å€¼æ¥æ”¶å®ƒï¼Œå¹¶è¿”å›ä»å®ƒè·å¾—çš„è¿­ä»£å™¨ï¼Œè€Œæ— æ‚¬å‚ä¹‹è™ã€‚   æ‰€ä»¥åº”è¯¥æ˜¯ç”Ÿæˆçš„viewsç±»ä¼¼äºå³å€¼ï¼Œå…¶è¿­ä»£å™¨ä¼šæ‚¬å‚å¤±æ•ˆï¼Œå¦‚æœå°†å®ƒèµ‹ç»™å·¦å€¼ï¼Œé‚£ä¹ˆmax_elementè¿”å›çš„è¿­ä»£å™¨å°±å¯ä»¥ä½¿ç”¨äº†ã€‚\n1 2  auto v = ... dp[i] = v.empty() ? 1 : *ranges::max_element(v) + 1;   è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œmax_elementåœ¨Rangeä¸ºç©ºæ—¶ï¼Œè¿”å›çš„æ˜¯rangs::begin(r)ã€‚æƒ³åœ¨ä¸€è¡Œå†™å®Œï¼Œè¿™ç‚¹é€»è¾‘ä¹Ÿä¸å¥½è¡¨ç¤ºã€‚ å› æ­¤C++çš„å‡½æ•°å¼ç¼–ç¨‹åœ¨æœ€åæ¶ˆè´¹è¿­ä»£å™¨çš„æ—¶å€™ï¼Œå†™æ³•ä¸æ˜¯å¾ˆä¾¿åˆ©ã€‚ åœ¨Rustä¸­ï¼Œç›¸ä¼¼çš„å†™æ³•æ˜¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  implSolution{pubfn length_of_lis(nums: Vec\u0026lt;i32\u0026gt;)-\u0026gt; i32 {letsz=nums.len();letmutdp: Vec\u0026lt;i32\u0026gt;=vec![0;sz];for(i,n)innums.iter().enumerate(){dp[i]=*dp.iter().take(i).enumerate().filter(|(j,_)|nums[*j]\u0026lt;*n).map(|(_,v)|v).max().unwrap_or(\u0026amp;0)+1;}*dp.iter().max().unwrap();}}  Rustä¸­è¿­ä»£å™¨çš„fpé£æ ¼å°±æ¯”è¾ƒè‡ªç„¶ï¼Œæœ€åæ¶ˆè´¹è¿­ä»£å™¨çš„maxæ–¹æ³•ï¼Œä¹Ÿæ˜¯èƒ½è¿”å›Option(T)ï¼Œå¯ä»¥ç›´æ¥å¤„ç†å®¹å™¨ä¸ºç©ºçš„æƒ…å†µäº†ã€‚ æ›´è¿›ä¸€æ­¥ï¼Œå¦‚æœä¸æƒ³ä¸¤æ¬¡å¾ªç¯dpçš„è¯ï¼Œå¸Œæœ›ç›´æ¥åœ¨ç¬¬ä¸€æ¬¡ç»™dpèµ‹å€¼æ—¶ï¼Œç›´æ¥æ±‚å‡ºæœ€å¤§å€¼ï¼Œä½†æ˜¯è¿™æ ·å†™æ˜¾ç„¶ä¼šé­é‡äº†é—­åŒ…æ•è·ä¸å¯å˜å¼•ç”¨ä¸å·²æœ‰å¯å˜å¼•ç”¨å†²çªçš„é—®é¢˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  implSolution{pubfn length_of_lis(nums: Vec\u0026lt;i32\u0026gt;)-\u0026gt; i32 {letsz=nums.len();letmutdp: Vec\u0026lt;i32\u0026gt;=vec![0;sz];*dp.iter_mut().enumerate().map(|(i,v)|{*v=*dp.iter().take(i).enumerate().filter(|(j,_)|nums[*j]\u0026lt;nums[i]).map(|(_,v)|v).max().unwrap_or(\u0026amp;0)+1;v}).max().unwrap()}}  å¯è§å¯¹è¿™ä¸ªé—®é¢˜ï¼Œä¸¤ä¸ªè¯­è¨€å†™æ³•éƒ½æŒºå¥‡æ€ªçš„ã€‚ä½†æ˜¯Rustæ˜æ˜¾å¯¹å‡½æ•°å¼ç¼–ç¨‹çš„æ”¯æŒæ›´å¥½ã€‚ç„¶è€Œä¹Ÿå¯ä»¥çœ‹åˆ°ç°åœ¨çš„ç¼–ç¨‹è¯­è¨€ç›¸äº’èåˆï¼Œè¶Šæ¥è¶Šåƒã€‚é™¤äº†Cã€‚\nå›åˆ°è¿™ä¸ªé—®é¢˜ï¼Œè¿˜æœ‰å¦ä¸€ç§æ–¹æ³•ï¼Œæ–°å»ºä¸€ä¸ªsubseqçš„vectorã€‚å¯¹äºæ¯ä¸ªnumï¼Œå¦‚æœå¤§äºsubseqæœ€åçš„å…ƒç´ ï¼Œåˆ™æ”¾å…¥subseqã€‚å¦åˆ™æ‰¾åˆ°subseqä¸­ç¬¬ä¸€ä¸ªå¤§äºç­‰äºnumçš„ä½ç½®ï¼Œæ›¿æ¢ä¸ºnumã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int max = 1; int sz = nums.size(); vector\u0026lt;int\u0026gt; subsq; for (int i = 0; i \u0026lt; sz; ++i) { if (subsq.empty() or nums[i] \u0026gt; subsq.back()) { subsq.push_back(nums[i]); } else { auto it = lower_bound(subsq.begin(), subsq.end(), nums[i]); if (it != subsq.end()) { *it = nums[i]; } } } return subsq.size(); } };   "},{"id":3,"href":"/post/flock/","title":"è®°ä¸€æ¬¡æ–‡ä»¶é”æ­»é”é—®é¢˜","section":"Posts","content":"flockæ˜¯Linuxç³»ç»Ÿæä¾›çš„ä¸€ä¸ªç³»ç»Ÿçº§çš„é”ï¼Œå¯ä»¥ç”¨ä½œè¿›ç¨‹é—´çš„åŒæ­¥ï¼Œman 2 flockï¼Œæ˜¾ç¤ºå…¶ç”¨æ³•æ˜¯\n1 2 3 4 5  NAME flock - apply or remove an advisory lock on an open file SYNOPSIS #include \u0026lt;sys/file.h\u0026gt; int flock(int fd, int operation);   operationå¯ä»¥å–å€¼ï¼š\n LOCK_SH å…±äº«é”ï¼Œè¯»é” LOCK_EX äº’æ–¥é”ï¼Œå†™é” LOCK_UN è§£é”æ“ä½œ  å¦å¤–ä¸€ä¸ªå‚æ•°fdæ˜¯æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰€ä»¥æ–‡ä»¶é”ä¸æ–‡ä»¶ç³»ç»Ÿå…³ç³»å¯†åˆ‡ï¼Œå…¶å®ç°åŸç†ä¹Ÿæ˜¯æŒ‚åœ¨æ‰“å¼€çš„æ–‡ä»¶ç»“æ„ä½“ä¸Šã€‚å› æ­¤å½“æ–‡ä»¶è¢«å…³é—­æ—¶ï¼Œä¹Ÿä¼šè§¦å‘è§£é”æ“ä½œã€‚\nåœ¨shellä¸­çš„ç”¨æ³•æ˜¯\n1  flock -x command arg # äº’æ–¥é”   æœ¬æ–‡è®°å½•ä¸€æ¬¡æ­»é”çš„é—®é¢˜ï¼Œç¨‹åºæ˜¯å¤šçº¿ç¨‹çš„ï¼ŒåŒæ—¶éœ€è¦forkä¸€ä¸ªå­è¿›ç¨‹å»æ‰§è¡Œè„šæœ¬ã€‚æˆ‘ä»¬å¸Œæœ›æ‰§è¡Œè„šæœ¬ä¸ç¨‹åºæœ¬èº«çš„å‡½æ•°è°ƒç”¨äº’æ–¥ã€‚äºæ˜¯åœ¨è„šæœ¬ä¸­è·å–äº’æ–¥é”ï¼Œåœ¨å‡½æ•°æ‰§è¡Œå‰è·å–å…±äº«é”ï¼Œä»è€Œè¾¾åˆ°äº’æ–¥çš„ç›®çš„ã€‚\nåˆšå¼€å§‹æµ‹è¯•æ—¶è¿è¡Œè‰¯å¥½ï¼Œåæ¥å‡ºç°ç¨‹åºå¡æ­»çš„é—®é¢˜ã€‚ä¸‹é¢æ¥æ¨¡æ‹Ÿä¸€ä¸‹å½“æ—¶çš„æƒ…å†µï¼š demo.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  #include \u0026lt;pthread.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/file.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; #define println(fmt, args...) printf(fmt\u0026#34;\\n\u0026#34;, ##args) #define log(fmt, args...) println(\u0026#34;[p%u][t%lu]\u0026#34;fmt, getpid(), pthread_self(), ##args)  const char *lockpath = \u0026#34;./f.lock\u0026#34;; int flock_wrap(int fd, int op) { int ret = flock(fd, op); if (ret == -1) { perror(\u0026#34;flock error\u0026#34;); } return ret; } int flock_sh(int fd) { log(\u0026#34;flock sh, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_SH | LOCK_NB); } int flock_ex(int fd) { log(\u0026#34;flock ex, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_SH | LOCK_NB); } int unlock(int fd) { log(\u0026#34;flock unlock, fd: %d\u0026#34;, fd); return flock_wrap(fd, LOCK_UN); } typedef void *(*StartRoutine)(void *); pthread_t spawn(StartRoutine start, void *arg) { pthread_t tid; int ret = pthread_create(\u0026amp;tid, NULL, start, arg); if (ret == -1) { perror(\u0026#34;pthread create error\u0026#34;); return 0; } return tid; } void do_something() { log(\u0026#34;do some things...\u0026#34;); sleep(2); } void do_something_wrap() { int fd = open(lockpath, O_WRONLY | O_CREAT); log(\u0026#34;open %s as %d\u0026#34;, lockpath, fd); if (fd == -1) { perror(\u0026#34;open error\u0026#34;); return; } if (flock_sh(fd) != -1) { do_something(); } log(\u0026#34;close %d\u0026#34;, fd); close(fd); } void *thread_start(void *notused) { do_something_wrap(); return NULL; } void fork_exec() { pid_t pid = fork(); if (pid == 0) { log(\u0026#34;In child\u0026#34;); execl(\u0026#34;/bin/bash\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;./do.sh\u0026#34;, NULL); exit(0); } else { waitpid(pid, NULL, WUNTRACED); } } int main(int argc, char **argv) { log(\u0026#34;main\u0026#34;); pthread_t tid = spawn(thread_start, NULL); sleep(1); fork_exec(); pthread_join(tid, NULL); return 0; }   do.sh:\n1 2 3  echo \u0026#34;[shell]=====start=====\u0026#34; flock -x f.lock echo \u0026#34;[shell]in flock ex\u0026#34; echo \u0026#34;[shell]======end======\u0026#34;   ç¨‹åºåœ¨å­è¿›ç¨‹ä¸­æ‰“å¼€é”æ–‡ä»¶ï¼Œå°è¯•è·å–å…±äº«é”ï¼Œç„¶åå…³é—­æ–‡ä»¶ã€‚\næ‰“å°æ—¥å¿—å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7  $ [p15641][t140500877805376]main [p15641][t140500877801024]open ./f.lock as 3 [p15641][t140500877801024]flock sh, fd: 3 [p15641][t140500877801024]do some things... [p15643][t140500877805376]In child [shell]=====start===== [p15641][t140500877801024]close 3   ä½¿ç”¨topï¼Œå¯ä»¥çœ‹åˆ°ä¸‰ä¸ªè¢«å¡ä½çš„è¿›ç¨‹\n1 2 3  15641 lcl 20 0 10960 1108 1016 S 0.0 0.0 0:00.00 fl 15643 lcl 20 0 7752 3372 3124 S 0.0 0.0 0:00.00 bash 15644 lcl 20 0 6172 944 856 S 0.0 0.0 0:00.00 flock   ä½¿ç”¨straceæŸ¥çœ‹\n1 2 3 4 5 6 7 8 9  $ strace -p 15641 strace: Process 15641 attached wait4(15643, $ strace -p 15643 strace: Process 15643 attached wait4(-1, $ strace -p 15644 strace: Process 15644 attached flock(4, LOCK_EX   flä¸»ç¨‹åºå¡åœ¨waitï¼Œshellè„šæœ¬çš„flockå‘½ä»¤å¡åœ¨ç­‰å¾…æ–‡ä»¶é”ä¸Šã€‚ä½†æ˜¯æˆ‘ä»¬çš„ç¨‹åºä¸­æ–‡ä»¶å·²ç»å…³é—­äº†ï¼Œä¸ºä»€ä¹ˆflockä¼šè¢«å¡ä½å‘¢ï¼Ÿ é€šè¿‡procä¿¡æ¯æŸ¥çœ‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ ls -l /proc/15641/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 $ ls -l /proc/15643/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 lr-x------ 1 lcl lcl 64 Oct 28 20:01 255 -\u0026gt; /home/lcl/repo/c/flock/do.sh l-wx------ 1 lcl lcl 64 Oct 28 20:01 3 -\u0026gt; /home/lcl/repo/c/flock/f.lock $ ls -l /proc/15644/fd total 0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 0 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 1 -\u0026gt; /dev/pts/0 lrwx------ 1 lcl lcl 64 Oct 28 20:01 2 -\u0026gt; /dev/pts/0 l-wx------ 1 lcl lcl 64 Oct 28 20:01 3 -\u0026gt; /home/lcl/repo/c/flock/f.lock lr-x------ 1 lcl lcl 64 Oct 28 20:01 4 -\u0026gt; /home/lcl/repo/c/flock/f.lock   å¯ä»¥çœ‹åˆ°åœ¨PID15643å’ŒPID15644ä¸­ï¼ŒæŒ‡å‘f.lockçš„fd 3ä¾ç„¶å­˜åœ¨ï¼Œåªæ˜¯åœ¨PID15641ä¸­è¢«å…³é—­äº†ã€‚ æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶é”ã€å¤šè¿›ç¨‹å¤šçº¿ç¨‹æ–‡ä»¶ç»§æ‰¿çš„é—®é¢˜ã€‚åœ¨çº¿ç¨‹ä¸­æ‰“å¼€çš„æ–‡ä»¶ï¼Œè¢«å­è¿›ç¨‹ç»§æ‰¿ï¼Œå½“å…³é—­æ–‡ä»¶æ—¶ï¼Œæ‰§è¡Œäº†execçš„å­è¿›ç¨‹å·²ç»æ–­å¼€å’ŒåŸä¸»è¿›ç¨‹çš„å…³ç³»ï¼Œæ‰“å¼€çš„æ–‡ä»¶å¾—ä»¥ä¿ç•™ã€‚å› æ­¤f.lockè¿™ä¸ªæ–‡ä»¶å¹¶æ²¡æœ‰è¢«æ‰€æœ‰è¿›ç¨‹å…³é—­ï¼ŒæŒ‚åœ¨è¿™ä¸ªæ–‡ä»¶ä¸Šçš„é”ä¹Ÿæ²¡æœ‰è¢«è§£é”ï¼Œå¯¼è‡´äº†æ­»é”é—®é¢˜ã€‚\nå…¶è¿‡ç¨‹å¦‚ä¸‹ï¼š å…¶è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œä½¿ç”¨æ˜¾å¼çš„UNLOCKè¿›è¡Œè§£é”ï¼Œå†è®¾ç½®æ–‡ä»¶çš„close_on_execå±æ€§åŠ ä¸€é‡ä¿é™©ã€‚\n"},{"id":4,"href":"/post/msm/","title":"boost meta state machine","section":"Posts","content":"MSM Meta State Machineï¼Œæ˜¯booståº“çš„å…ƒçŠ¶æ€æœºï¼Œä½¿ç”¨äº†å¤§é‡çš„æ¨¡æ¿å…ƒç¼–ç¨‹ï¼Œè®©ä½¿ç”¨è€…è½»æ¾åˆ›å»ºå‡ºå¥½ç”¨ï¼Œå¯é˜…è¯»ï¼Œæ•ˆç‡é«˜çš„çŠ¶æ€æœºã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯ä½¿ç”¨çŠ¶æ€è½¬ç§»è¡¨ transition_table æ¥å®šä¹‰çŠ¶æ€æœºè½¬ç§»çš„è¿‡ç¨‹ï¼Œéå¸¸ç›´è§‚ï¼Œæ˜“äºé˜…è¯»ï¼Œä¿®æ”¹ï¼Œæ’é”™å’Œä¿®æ”¹ã€‚çŠ¶æ€è½¬ç§»è¡¨çš„è¦ç´ æ˜¯æºçŠ¶æ€ Sourcce Stateï¼Œç›®æ ‡çŠ¶æ€ Target Stateï¼Œè§¦å‘äº‹ä»¶Eventï¼Œå®ˆå«æ¡ä»¶Guardå’Œæ‰§è¡ŒåŠ¨ä½œActionã€‚\næœ¬æ–‡ä»£ç ç¤ºä¾‹åœ¨boost_msm_guide\nä»ä¸€ä¸ªç®€å•çš„çŠ¶æ€æœºå¼€å§‹ #  ä½¿ç”¨boost msmå®šä¹‰ä¸€ä¸ªç®€å•çš„çŠ¶æ€æœºåˆ†ä¸º6æ­¥ï¼š\n å®šä¹‰äº‹ä»¶Event å®šä¹‰çŠ¶æ€æœºfront-end boost::msm::front::state_machine_def å®šä¹‰çŠ¶æ€ è®¾ç½®åˆå§‹çŠ¶æ€ å®šä¹‰çŠ¶æ€è½¬ç§»è¡¨ ç”ŸæˆçŠ¶æ€æœºback-end  çŠ¶æ€æœºä½¿ç”¨æ—¶\n å®šä¹‰çŠ¶æ€æœºå®ä¾‹fsm å¼€å§‹çŠ¶æ€æœºfsm.start() å¤„ç†äº‹ä»¶fsm.process_event()  é¦–å…ˆä»ä¸€ä¸ªåªæœ‰çŠ¶æ€è½¬ç§»çš„ç®€å•çŠ¶æ€æœºå¼€å§‹\nä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;boost/msm/back/state_machine.hpp\u0026gt;#include \u0026lt;boost/msm/front/state_machine_def.hpp\u0026gt;#include \u0026lt;boost/msm/front/functor_row.hpp\u0026gt;#include \u0026lt;iostream\u0026gt; namespace { // ---Events  struct Event1 {}; // ---State Machine front-end  struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // States  struct State1 : boost::msm::front::state\u0026lt;\u0026gt; { // Entry Action  template\u0026lt;class Event, class Fsm\u0026gt; void on_entry(Event const\u0026amp;, Fsm\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;Entering State1\\n\u0026#34;; } // Exit Action  template\u0026lt;class Event, class Fsm\u0026gt; void on_exit(Event const\u0026amp;, Fsm\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;Leaving State1\\n\u0026#34;; } }; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // Set initial state  using initial_state = State1; // Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start | Event | Next | Action | Guard  _row\u0026lt; State1, Event1, End \u0026gt; \u0026gt; {}; }; // Pick a back-end  using Fsm = boost::msm:ğŸ”™:state_machine\u0026lt;Sm\u0026gt;; void test() { Fsm fsm; fsm.start(); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event1\\n\u0026#34;; fsm.process_event(Event1{}); } } int main() { test(); return 0; }   ç¼–è¯‘è¿è¡Œæ­¤çŠ¶æ€ï¼Œæ‰“å°æ˜¯\n1 2 3  Entering State1 \u0026gt; Send Event1 Leaving State1   State #  çŠ¶æ€æœºçš„ç¬¬ä¸€è¦ç´ å½“ç„¶æ˜¯çŠ¶æ€ï¼Œä¸€ä¸ªçŠ¶æ€æœºçš„ä¸€ç”Ÿå°±æ˜¯åœ¨å„ä¸ªçŠ¶æ€é—´æ¥æ¥å»å»ã€‚çŠ¶æ€é—´çš„è¿ç§»ç”±Eventäº‹ä»¶è§¦å‘ï¼Œè¿ç§»ä¸­é—´å¯ä»¥æ‰§è¡ŒActionï¼Œæ˜¯å¦èƒ½è¿ç§»å–å†³äºGuardã€‚æ¯ä¸ªçŠ¶æ€å¸¦æœ‰on_entryå’Œon_exitä¸¤ä¸ªæ–¹æ³•ï¼Œé¡¾åæ€ä¹‰ï¼Œåœ¨è¿›å…¥å’Œç¦»å¼€æ—¶è§¦å‘ã€‚\nä¸ºäº†åç»­æ›´å¥½çš„æ¼”ç¤ºï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªbase classæ‰§è¡Œä¸€äº›åŸºç¡€çš„æ‰“å°ã€‚\né¦–å…ˆï¼Œè·å–typeçš„åç§°ã€‚æˆ‘ä»¬çŸ¥é“æ ‡å‡†åº“ä¸­çš„typeid(var).name()æ–¹æ³•å¯ä»¥è·å–åˆ°å˜é‡çš„ç±»å‹åç§°ï¼Œä½†æ˜¯æ˜¯å†…éƒ¨çš„ç¬¦å·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡boost::core::demangleæ–¹æ³•æ¥è·å–æ›´æ˜“è¯»çš„åç§°ï¼ŒåŒæ—¶æŠŠå‘½åç©ºé—´çš„å‰ç¼€å»æ‰ã€‚\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; std::string get_typename(const T \u0026amp;x) { std::string name = boost::core::demangle(typeid(x).name()); auto pos = name.rfind(\u0026#34;::\u0026#34;); if (pos != std::string::npos) { name = name.substr(pos + 2); } return name; }   BaseStateè´Ÿè´£åœ¨on_entryå’Œon_exitæ—¶æ‰“å°æ—¥å¿—ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•ç”±çŠ¶æ€æœºåœ¨è¿›å…¥å’Œç¦»å¼€çŠ¶æ€æ—¶è‡ªåŠ¨è°ƒç”¨ã€‚ä¸ºäº†ç»§æ‰¿çš„å­ç±»å¯ä»¥å®šåˆ¶ä¸€äº›åŠ¨ä½œï¼Œå®šä¹‰äº†è™šå‡½æ•°prepareå’Œcleanï¼Œå‚æ•°ä¸ºçŠ¶æ€æœºå†…çš„ctxã€‚å®é™…ä¸Šï¼Œè¿™é‡Œå’Œon_entryä¸€æ ·ä¼ å…¥template Eventå’ŒFsmå‚æ•°æ›´å¥½ï¼Œä½†æ˜¯ç”±äºc++è¯­è¨€çš„é™åˆ¶ï¼Œæ¨¡æ¿å‡½æ•°ä¸èƒ½ä¸ºè™šå‡½æ•°ï¼Œæ‰€ä»¥é€€è€Œæ±‚å…¶æ¬¡ï¼Œä¼ å…¥ä¸€ä¸ªæ–°çš„Contextå˜é‡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct BaseState : boost::msm::front::state\u0026lt;\u0026gt; { virtual ~BaseState() {} template\u0026lt;class Event, class Fsm\u0026gt; void on_entry(Event const \u0026amp;event, Fsm \u0026amp;fsm) { std::cout \u0026lt;\u0026lt; \u0026#34;[state]...Entering \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; prepare(fsm.ctx); } template\u0026lt;class Event, class Fsm\u0026gt; void on_exit(Event const \u0026amp;event, Fsm \u0026amp;fsm) { std::cout \u0026lt;\u0026lt; \u0026#34;[state]...Leaving \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; clean(fsm.ctx); } virtual void prepare(Context \u0026amp;) {} virtual void clean(Context \u0026amp;) {} };   ç°åœ¨ï¼Œæˆ‘ä»¬çš„çŠ¶æ€æœºå¾—ä»¥ç²¾ç®€\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // ---States  struct State1 : BaseState {}; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // ---Set initial state  using initial_state = State1; // ---Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start | Event | Next | Action | Guard  _row\u0026lt; State1, Event1, End \u0026gt; \u0026gt; {}; Context ctx; }; // ---Pick a back-end using Fsm = boost::msm:ğŸ”™:state_machine\u0026lt;Sm\u0026gt;;   æ‰“å°æ˜¯\n1 2 3  [state]...Entering State1 by InitEvent \u0026gt; Send Event1 [state]...Leaving State1 by Event1   å€¼å¾—æ³¨æ„çš„æ˜¯InitEventï¼Œå®ƒæ˜¯ä»å“ªæ¥çš„ï¼Ÿæˆ‘ä»¬çš„transition_tableå¹¶æ²¡æœ‰å®šä¹‰è¿™ä¸ªäº‹ä»¶ï¼å®é™…ä¸Šï¼Œè¿™æ˜¯Fsmè¿›å…¥initial_stateçš„é»˜è®¤è§¦å‘äº‹ä»¶ã€‚\nAction #  Actionå‘ç”Ÿåœ¨ç¦»å¼€çŠ¶æ€åï¼Œè¿›å…¥ä¸‹ä¸€çŠ¶æ€å‰ã€‚å¯ä»¥ä½¿ç”¨ä¸€ä¸ªFunctor classæ¥è¡¨ç¤ºã€‚å’ŒStateä¸€æ ·ï¼Œè¿™é‡Œå®šä¹‰ä¸€ä¸ªBaseActionçš„ç±»ã€‚\n1 2 3 4 5 6 7 8 9 10 11  struct BaseAction { virtual ~BaseAction() {} template\u0026lt;class Event, class Fsm, class SourceState, class TargetState\u0026gt; void operator()(Event const \u0026amp;event, Fsm \u0026amp;fsm, SourceState const \u0026amp;from, TargetState const \u0026amp;to) { std::cout \u0026gt;\u0026gt; \u0026#34;[action] Do \u0026#34; \u0026gt;\u0026gt; get_typename(*this) \u0026gt;\u0026gt; \u0026#34; from \u0026#34; \u0026gt;\u0026gt; \u0026gt;\u0026gt; get_typename(from) \u0026gt;\u0026gt; \u0026#34; to \u0026#34; \u0026gt;\u0026gt; get_typename(to) \u0026gt;\u0026gt; \u0026gt;\u0026gt; \u0026#34; by \u0026#34; \u0026gt;\u0026gt; get_typename(event) \u0026gt;\u0026gt; \u0026#34;\\n\u0026#34;; execute(fsm.ctx); } virtual void execute(Context \u0026amp;) {} };   Guard #  Guardå‘ç”Ÿåœ¨ç¦»å¼€çŠ¶æ€å‰ï¼Œè¿”å›ä¸€ä¸ªboolå€¼ï¼Œå¦‚æœä¸ºtrueï¼Œåˆ™å¯ä»¥è½¬ç§»ï¼Œå¦åˆ™ä¿æŒåœ¨åŸçŠ¶æ€ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12  struct BaseGuard { virtual ~BaseGuard() {} template\u0026lt;class Event, class Fsm, class SourceState, class TargetState\u0026gt; bool operator()(Event const \u0026amp;event, Fsm \u0026amp;fsm, SourceState const \u0026amp;from, TargetState const \u0026amp;to) { bool ok = execute(fsm.ctx); std::cout \u0026lt;\u0026lt; \u0026#34;[guard] \u0026#34; \u0026lt;\u0026lt; get_typename(*this) \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; ok \u0026lt;\u0026lt; \u0026#34; from \u0026#34; \u0026lt;\u0026lt; get_typename(from) \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; get_typename(to) \u0026lt;\u0026lt; \u0026#34; by \u0026#34; \u0026lt;\u0026lt; get_typename(event) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return ok; } virtual bool execute(Context \u0026amp;) {return true;} };   transition_table #  çŠ¶æ€è½¬ç§»è¡¨çš„å®Œæ•´å½¢æ€æ˜¯5ä¸ªå…ƒç´ ï¼š fromStateï¼Œ Eventï¼Œ ToStateï¼Œ Actionï¼Œ Guard ä¸€èˆ¬ä½¿ç”¨functor_rowé‡Œçš„boost::msm::front::Rowæ¥å®šä¹‰è½¬ç§»è¡¨çš„æ¯ä¸€è¡Œã€‚å…¶ä¸­ç©ºçš„è¦ç´ ä½¿ç”¨boost::msm::front::noneæ¥è¡¨ç¤ºã€‚ å¯ä»¥ä½¿ç”¨usingæ¥ç®€åŒ–è¿™ä¸ªä¸¤ä¸ªç±»å‹\n1 2 3 4  template\u0026lt;typename... T\u0026gt; using Row = boost::msm::front::Row\u0026lt;T...\u0026gt;; using None = boost::msm::front::none;   è‡³æ­¤æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå®Œæ•´çš„çŠ¶æ€äº†ã€‚\nä»£ç ä¸º\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // ---State Machine front-end struct Sm : boost::msm::front::state_machine_def\u0026lt;Sm\u0026gt; { // ---States  struct State1 : BaseState {}; struct State2 : BaseState {}; struct Init : BaseState {}; struct End : boost::msm::front::terminate_state\u0026lt;\u0026gt; {}; // ---Events  struct Event1 {}; struct Event2 {}; // ---Actions  struct Action1 : BaseAction {}; struct Action2 : BaseAction {}; // ---Guard  struct Guard1 : BaseGuard {}; struct GTrue : BaseGuard {}; struct GFalse : BaseGuard { bool execute(Context \u0026amp;) override { return false; } }; // ---Set initial state  using initial_state = Init; template\u0026lt;typename... T\u0026gt; using Row = boost::msm::front::Row\u0026lt;T...\u0026gt;; using None = boost::msm::front::none; // ---Transition Table  struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, State2, Action1, Guard1 \u0026gt;, Row\u0026lt; State2, Event2, End, Action2, None \u0026gt; \u0026gt; {}; Context ctx; }; // ---Pick a back-end using Fsm = boost::msm:ğŸ”™:state_machine\u0026lt;Sm\u0026gt;; void test() { Fsm fsm; fsm.start(); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event1\\n\u0026#34;; fsm.process_event(Event1{}); std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; Send Event2\\n\u0026#34;; fsm.process_event(Event2{}); }   è¾“å‡ºä¸º\n1 2 3 4 5 6 7 8 9 10 11  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] Guard1 -\u0026gt; true from State1 to State2 by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to State2 by Event1 [state]...Entering State2 by Event1 \u0026gt; Send Event2 [state]...Leaving State2 by Event2 [action] Do Action2 from State2 to End by Event2   if-else #  åœ¨transition_tableä¸­ï¼Œåœ¨ä¸‹æ–¹çš„rowä¼˜å…ˆäºä¸Šæ–¹çš„rowå…ˆæ‰§è¡Œã€‚\nè¿™ä¸€èŠ‚é€šè¿‡å®ç°ä¸€ä¸ªif-elseçš„é€»è¾‘æ¥è¯´æ˜åœ¨transition_tableé‡Œrowçš„ä¼˜å…ˆçº§ã€‚\nä¸¤ä¸ªAction\n1 2 3 4 5 6 7 8 9 10 11  // ---Actions struct SetVal1 : BaseAction { void execute(Context \u0026amp;ctx) override { ctx.val = 1; } }; struct SetVal2 : BaseAction { void execute(Context \u0026amp;ctx) override { ctx.val = 2; } };   Guard\n1 2 3 4 5  struct IfGuard : BaseGuard { bool execute(Context \u0026amp;ctx) override { return ctx.val == 1; } };   transition_table\n1 2 3 4 5 6 7 8 9 10  // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init , Event1 , State1 , SetVal1 , None \u0026gt;, Row\u0026lt; Init , Event2 , State1 , SetVal2 , None \u0026gt;, Row\u0026lt; State1 , None , ElseState , None , None \u0026gt;, Row\u0026lt; State1 , None , IfState , None , IfGuard\u0026gt;, Row\u0026lt; IfState, None , Init , None , None \u0026gt;, Row\u0026lt; ElseState, None , Init , None , None \u0026gt; \u0026gt; {};   è¾“å‡ºä¸º\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [state]...Entering Init by InitEvent \u0026gt; Send Event1 [state]...Leaving Init by Event1 [action] Do SetVal1 from Init to State1 by Event1 [state]...Entering State1 by Event1 [guard] IfGuard -\u0026gt; true from State1 to IfState by none [state]...Leaving State1 by none [state]...Entering IfState by none [state]...Leaving IfState by none [state]...Entering Init by none \u0026gt; Send Event2 [state]...Leaving Init by Event2 [action] Do SetVal2 from Init to State1 by Event2 [state]...Entering State1 by Event2 [guard] IfGuard -\u0026gt; false from State1 to IfState by none [state]...Leaving State1 by none [state]...Entering ElseState by none [state]...Leaving ElseState by none [state]...Entering Init by none   çŠ¶æ€è‡ªè½¬ç§» #  è½¬ç§»åˆ°è‡ªå·±æœ¬èº«æœ‰ä¸¤ç§æ–¹å¼ï¼Œå¯ä»¥ç§°ä¸ºå¤–éƒ¨è‡ªè½¬ç§»å’Œå†…éƒ¨è‡ªè½¬ç§»ã€‚å¦‚\n1 2 3 4 5 6 7  // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, State1, Action1, Guard1 \u0026gt;, Row\u0026lt; State1, Event2, None , Action2, GTrue \u0026gt; \u0026gt; {};    startå’Œnextéƒ½æ˜¯State1ï¼Œæ­¤æ—¶ä¼šæ‰§è¡ŒState1çš„on_exitå’Œon_entryã€‚ nextæ—¶Noneï¼Œä¸ä¼šæ‰§è¡Œon_exitå’Œon_entryã€‚  1 2 3 4 5 6 7 8 9 10 11  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] Guard1 -\u0026gt; true from State1 to State1 by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to State1 by Event1 [state]...Entering State1 by Event1 \u0026gt; Send Event2 [guard] GTrue -\u0026gt; true from State1 to State1 by Event2 [action] Do Action2 from State1 to State1 by Event2   exception #  çŠ¶æ€æœºçš„on_entry, on_exit, Action, Guardéƒ½å¯èƒ½æŠ›å‡ºå¼‚å¸¸ï¼Œä¸è‡ªå·±å¤„ç†çš„è¯ï¼Œç¨‹åºä¼šå¼‚å¸¸é€€å‡ºã€‚å¯ä»¥é€šè¿‡è‡ªå·±å®šä¹‰exception_caughtæ–¹æ³•æ¥è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†ã€‚ å¦å¤–æˆ‘ä»¬å¯ä»¥é‡è½½no_transitionçš„æ–¹æ³•æ¥å¤„ç†æ²¡æœ‰å¯¹åº”çŠ¶æ€è½¬ç§»è§„åˆ™çš„æƒ…å†µã€‚ ä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;class Event, class Fsm\u0026gt; void exception_caught (Event const\u0026amp; evt, Fsm\u0026amp; fsm,std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;catch exception \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34; while \u0026#34; \u0026lt;\u0026lt; get_typename(evt) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;class Event, class Fsm\u0026gt; void no_transition(Event const\u0026amp; evt, Fsm \u0026amp;fsm, int x) { std::cout \u0026lt;\u0026lt; \u0026#34;No transition item for \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; while \u0026#34; \u0026lt;\u0026lt; get_typename(evt) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   é’ˆå¯¹äº§ç”Ÿå¼‚å¸¸çš„ä¸åŒæ—¶æœºï¼Œå…¶è¡¨ç°æœ‰æ‰€ä¸åŒã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªout_of_rangeçš„å¼‚å¸¸æ¥çœ‹ä¸€ä¸‹å®é™…ç»“æœã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void sth_wrong() { std::vector\u0026lt;int\u0026gt; a(1); int i = a.at(2); } struct ExceptionOnEntry : BaseState { void prepare(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionOnExit : BaseState { void clean(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionAction : BaseAction { void execute(Context \u0026amp;) override { sth_wrong(); } }; struct ExceptionGuard : BaseGuard { bool execute(Context \u0026amp;) override { sth_wrong(); return true; } }; // ---Transition Table struct transition_table : boost::mpl::vector\u0026lt; // Start * Event * Next * Action * Guard  Row\u0026lt; Init, None, State1, None, None \u0026gt;, Row\u0026lt; State1, Event1, ExceptionOnEntry, Action1, GTrue \u0026gt;, Row\u0026lt; State1, Event2, State2, ExceptionAction, GTrue \u0026gt;, Row\u0026lt; State1, Event3, State2, Action1, ExceptionGuard \u0026gt;, Row\u0026lt; State1, Event4, ExceptionOnExit, Action1, GTrue \u0026gt;, Row\u0026lt; ExceptionOnExit, Event5, State1, Action1, GTrue \u0026gt; \u0026gt; {};   è¿è¡Œç»“æœ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [state]...Entering Init by InitEvent [state]...Leaving Init by none [state]...Entering State1 by none \u0026gt; Send Event1 [guard] GTrue -\u0026gt; true from State1 to ExceptionOnEntry by Event1 [state]...Leaving State1 by Event1 [action] Do Action1 from State1 to ExceptionOnEntry by Event1 [state]...Entering ExceptionOnEntry by Event1 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event1 \u0026gt; Send Event2 [guard] GTrue -\u0026gt; true from State1 to State2 by Event2 [state]...Leaving State1 by Event2 [action] Do ExceptionAction from State1 to State2 by Event2 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event2 \u0026gt; Send Event3 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event3 \u0026gt; Send Event4 [guard] GTrue -\u0026gt; true from State1 to ExceptionOnExit by Event4 [state]...Leaving State1 by Event4 [action] Do Action1 from State1 to ExceptionOnExit by Event4 [state]...Entering ExceptionOnExit by Event4 \u0026gt; Send Event5 [guard] GTrue -\u0026gt; true from ExceptionOnExit to State1 by Event5 [state]...Leaving ExceptionOnExit by Event5 catch exception vector::_M_range_check: __n (which is 2) \u0026gt;= this-\u0026gt;size() (which is 1) while Event5 \u0026gt; Send Event1 No transition item for 2 while Event1   å¯ä»¥æ€»ç»“ï¼š ä¸€æ¬¡çŠ¶æ€è¿ç§»çš„è¿‡ç¨‹åˆ†ä¸ºguard-\u0026gt;on_exit-\u0026gt;action-\u0026gt;on_entryã€‚å…¶ä¸­æŸä¸€æ­¥æŠ›å‡ºå¼‚å¸¸æ—¶ï¼ŒçŠ¶æ€éƒ½ä¼šå›åˆ°sourceStateã€‚\n"},{"id":5,"href":"/post/hugo_and_git_submodule/","title":"Hugo and git submodule","section":"Posts","content":"ä»‹ç» #  hugo + giteeæ­å»ºä¸ªäººåšå®¢ï¼Œä½¿ç”¨giteeä»£æ›¿githubæ˜¯å› ä¸ºå›½å†…è®¿é—®é€Ÿåº¦é—®é¢˜ã€‚\nhugoç›´æ¥åœ¨ä»“åº“å¯ä»¥å®‰è£…sudo apt install hugoï¼Œè¿™ä¸ªé“¾æ¥æ˜¯å®ƒçš„å®˜æ–¹ç½‘é¡µã€‚\nhugo new xxx.mdåœ¨postä¸­æ–°å»ºMarkdownæ ¼å¼çš„æ–‡ç« ï¼Œæ³¨æ„æ­¤æ—¶åœ¨å¼€å¤´å±æ€§é‡Œæœ‰draft: trueçš„æ ‡å¿—ï¼Œè¿™ä¼šå¯¼è‡´æ­¤ç¯‡æ–‡ç« ä¸èƒ½å‘å¸ƒã€‚ åæœŸéœ€è¦åˆ é™¤æ­¤è¡Œã€‚\nhugo -t $themeç”Ÿæˆpublicæ–‡ä»¶å¤¹ä¸­çš„é™æ€ç½‘é¡µã€‚\nhugo serverå¯ä»¥æœ¬åœ°èµ·ä¸€ä¸ªæœåŠ¡å™¨ï¼Œè¿™æ—¶é€šè¿‡æµè§ˆå™¨æŸ¥çœ‹ç½‘é¡µæ•ˆæœã€‚\ngit submodule #  hugoä¸»é¢˜å’Œé™æ€ç½‘é¡µæ˜¯å¦å¤–çš„gitåº“ï¼Œä¸ºäº†æ–¹ä¾¿ç®¡ç†ï¼Œå¼•å…¥git submoduleçš„ç”¨æ³•ã€‚\næ¯”å¦‚æˆ‘ä½¿ç”¨çš„hugoä¸»é¢˜æ˜¯evenï¼Œå¯ä»¥ä½¿ç”¨å‘½ä»¤\n1  git submodule add https://gitee.com/xxxxx/hugo-theme-even.git themes/even   æ¥æ·»åŠ å­æ¨¡å—ã€‚\ngiteeæä¾›çš„é™æ€ç½‘é¡µï¼Œåœ¨ä»“åº“çš„æœåŠ¡-\u0026gt;Gitee Pageså¯ä»¥æ‰¾åˆ°ã€‚å³æ–°å»ºä¸€ä¸ªåŒåçš„ä»“åº“å°±å¯ä»¥äº†ã€‚åŒæ ·æ·»åŠ \n1  git submodule add -b master https://gitee.com/lclei/lclei.git public   æ·»åŠ åï¼Œä¸»ç›®å½•é‡Œä¼šæœ‰.gitmodulesæ–‡ä»¶è®°å½•ã€‚\n1 2 3 4 5 6 7 8  $ cat .gitmodules [submodule \u0026#34;themes/even\u0026#34;] path = themes/even url = https://gitee.com/gkzhb/hugo-theme-even.git [submodule \u0026#34;public\u0026#34;] path = public url = https://gitee.com/lclei/lclei.git branch = master   gitæ²¡æœ‰æä¾›submoduleçš„åˆ é™¤å‘½ä»¤ã€‚æœ‰å‡ºé”™ç­‰æƒ…å†µï¼Œå¯ä»¥å».gitç›®å½•ä¸‹æ‰¾åˆ°modulesç›®å½•ï¼Œåˆ é™¤å¯¹åº”submoduleã€‚\néƒ¨ç½² #  æœ€åè®°å½•è‡ªå·±çš„deploy.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to Gitee...\\033[0m\\n\u0026#34; # Build the project. hugo -t even # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master cd ..   "},{"id":6,"href":"/post/non_cursive_tree_traversal/","title":"äºŒå‰æ ‘çš„éé€’å½’éå†","section":"Posts","content":"äºŒå‰æ ‘çš„éå†æœ‰å‰åºï¼Œä¸­åºï¼Œååºä»¥åŠå±‚æ¬¡éå†ï¼Œå…¶ä¸­å‰åºï¼Œä¸­åºå’Œååºéå†ä½¿ç”¨é€’å½’æ¥å†™éå¸¸ç®€å•ã€‚ ä¾‹å¦‚\n1 2 3 4 5 6 7  void tree_preorder_re(TreeNode *node, Tree *tree, void (*visit)(Tree *, TreeNode *)) { if (!node) return; visit(tree, node); tree_preorder_re(node-\u0026gt;left, tree, visit); tree_preorder_re(node-\u0026gt;right, tree, visit); }   ä¸­åºå’Œååºï¼Œä¸è¿‡æ˜¯è°ƒæ•´ä¸€ä¸‹visitçš„ä½ç½®ï¼Œå¦‚æœä¸ç”¨é€’å½’çš„å†™æ³•ï¼Œæ”¹ç”¨æ ˆæ¥å®ç°ï¼Œå…¶å®æ²¡æœ‰é‚£ä¹ˆç›´è§‚ã€‚ é¦–å…ˆæŒ‰ç…§å‡½æ•°è°ƒç”¨çš„å…³ç³»ï¼Œå…¥æ ˆçš„å¥—è·¯éƒ½æ˜¯ä¸€æ ·çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while (stack_depth(s) != 0 || tNode) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); tNode = tNode-\u0026gt;right; } } stack_free(s);   å‰åºéå† #  å‰åºéå†æœ€ç®€å•ï¼Œåœ¨èŠ‚ç‚¹å…¥æ ˆçš„æ—¶å€™è®¿é—®ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void tree_preorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while (stack_depth(s) != 0 || tNode) { while (tNode != NULL) { stack_push(s, tNode); visit(tree, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); tNode = tNode-\u0026gt;right; } } stack_free(s); }   ä¸­åºéå† #  åœ¨èŠ‚ç‚¹å‡ºæ ˆçš„æ—¶å€™è®¿é—®ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void tree_inorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; while(stack_depth(s) != 0 || tNode != NULL) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_pop(s); visit(tree, tNode); tNode = tNode-\u0026gt;right; } } stack_free(s); }   ååºéå† #  ä¿è¯å·¦å³èŠ‚ç‚¹éƒ½è®¿é—®ä¹‹åï¼Œå†è®¿é—®çˆ¶èŠ‚ç‚¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void tree_postorder(Tree *tree, void (*visit)(Tree *, TreeNode *)) { Stack *s = stack_new(); TreeNode *tNode = tree-\u0026gt;root; TreeNode *last_visit = NULL; while(tNode != NULL || !stack_is_empty(s)) { while (tNode != NULL) { stack_push(s, tNode); tNode = tNode-\u0026gt;left; } if (!stack_is_empty(s)) { tNode = (TreeNode *)stack_top(s); if (tNode-\u0026gt;right == NULL || tNode-\u0026gt;right == last_visit) { stack_pop(s); last_visit = tNode; visit(tree, tNode); tNode = NULL; } else { tNode = tNode-\u0026gt;right; } } } stack_free(s); }   éªŒè¯\n1 2 3 4 5 6 7 8 9 10 11 12  main(251): __debug preorder recursive--- 1 2 4 5 3 6 7 main(254): __debug preorder non-recursive--- 1 2 4 5 3 6 7 main(257): __debug inorder recursive--- 4 2 5 1 6 3 7 main(260): __debug inorder non-recursive--- 4 2 5 1 6 3 7 main(263): __debug postorder recursive--- 4 5 2 6 7 3 1 main(266): __debug postorder non_ecursive--- 4 5 2 6 7 3 1   "},{"id":7,"href":"/post/udisk-grub/","title":"ä½¿ç”¨grubåˆ›å»ºå¤šç³»ç»Ÿuç›˜å®‰è£…ç›˜","section":"Posts","content":"ç°åœ¨è£…ç³»ç»Ÿéƒ½æ˜¯ç”¨uç›˜å®‰è£…äº†ï¼Œä¸€ä¸ªuç›˜åªèƒ½å®‰è£…ä¸€ä¸ªç³»ç»Ÿæœ‰äº›æµªè´¹äº†ï¼Œå› ä¸ºç©ºé—´è¶³å¤Ÿå¤§ï¼Œå¯ä»¥è£…ä¸‹å¥½å‡ ä¸ªisoæ–‡ä»¶ã€‚ åœ¨linuxç¯å¢ƒä¸­ï¼Œä½¿ç”¨ddå‘½ä»¤åªèƒ½åˆ¶ä½œä¸€ä¸ªå¼•å¯¼ç›˜ï¼Œä¸”å…¶ä»–ç©ºé—´ä¸èƒ½å†ä½¿ç”¨ã€‚ä»ç½‘ä¸Šçœ‹ç”¨YUMIå¯ä»¥æ¯”è¾ƒæ–¹ä¾¿çš„åˆ¶ä½œå¤šç³»ç»Ÿå¼•å¯¼ã€‚ç„¶è€Œå®æµ‹å‘ç°æ˜¯linuxç³»ç»Ÿä¸Šå®åœ¨å¤ªéš¾ç”¨ï¼Œè£…WINEä¹Ÿç”¨ä¸äº†ã€‚åæ¥çœ‹åˆ°grubçš„æ–¹æ³•æˆåŠŸå®ç°äº†ã€‚\ngrubçš„æ–¹æ³•åˆ†ä¸ºä¸¤æ­¥ï¼š\n å¯¹uç›˜åˆ†åŒºï¼Œæ‹·å…¥isoæ–‡ä»¶ å®‰è£…grubï¼Œç¼–è¾‘grub.cfg  uç›˜åˆ†åŒº #  é¦–å…ˆå¯ä»¥æ‰¾ä¸€æ‰¾æ˜¯å¦æœ‰ç°æˆçš„åˆ†åŒºè½¯ä»¶å¯ä»¥ç”¨ï¼Œæ¯”å¦‚manjaro-kdeè‡ªå¸¦çš„KDE partion managerã€‚\nä¸‹é¢è¿˜æ˜¯ç»™å‡ºfdiskçš„å‘½ä»¤æ¥å¤ç›˜æ•´ä¸ªè¿‡ç¨‹ã€‚\n1 2 3 4 5 6 7 8 9 10  sudo su # æå‡æƒé™æ–¹ä¾¿åç»­æ“ä½œ fdisk -l # æŸ¥çœ‹å½“å‰åˆ†åŒºï¼ŒæŸ¥æ‰¾åˆ°uç›˜å¯¹åº”çš„ä½ç½®ï¼Œæ¯”å¦‚/dev/sdb mkfs /dev/sdb # æ ¼å¼åŒ– fdisk /dev/sdb # åˆ†åŒºå¼€å§‹ d # åˆ é™¤åŸåˆ†åŒº n # æ–°åˆ†åŒº a # å¢åŠ å¼•å¯¼æ ‡å¿— t # æ›´æ”¹ç±»å‹ w # å†™å…¥ä¿å­˜ m # çœ‹help   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  I. Format your USB Flash Drive to use a Single Partition: Open a terminal and type sudo su Type fdisk -l (and note which device is your USB Drive) Type fdisk /dev/sdx (replacing x with your actual usb device) Type d (to delete the existing partition) Type n (to create a new partition) Type p (for primary partition) Type 1 (to create the first partition) Press Enter (to use the first cylinder) Press Enter again (to use the default value as the last cylinder) Type a (for active) Type 1 (to mark the first partition active \u0026#34;bootable\u0026#34;) Type t (for partition type) Type c (to use fat32 partition) Type w (to write the changes and close fdisk) II. Create a Fat32 Filesystem on the USB Flash Drive: Type umount /dev/sdx1 (to unmount the mounted partition) Type mkfs.vfat -F 32 -n MULTIBOOT /dev/sdx1 (to format the partition as fat32) Remove and reinsert your USB flash drive, or remount it   grub #  æŒ‚è½½ï¼Œå®‰è£…grub\n1 2  mount /dev/sdb1 /mnt/udisk/linux/ grub-install --root-directory=/mnt/udisk/linux/ --boot-directory=/mnt/udisk/linux/boot/ --no-floppy /dev/sdb   grubé…ç½®ï¼Œå„linuxå‘è¡Œç‰ˆçš„grub menuéƒ½ä¸å¤ªä¸€æ ·ï¼Œéœ€è¦ä»ç½‘ä¸ŠæŸ¥æ‰¾ä»¥åŠå’Œisoä¸­çš„æ–‡ä»¶è¿›è¡Œæ¯”å¯¹ï¼Œæˆ‘ç°åœ¨ç”¨çš„manjaroå’Œubuntuçš„é…ç½®å¦‚ä¸‹ï¼Œäº²æµ‹å¯ä»¥ä½¿ç”¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  set timeout=10 insmod fat set default=0 loadfont /boot/grub/fonts/unicode.pf2 set gfxmode=1920x1080 set theme=\u0026#34;/boot/grub/themes/starfield/theme.txt\u0026#34; export theme set gfxpayload=keep insmod gfxterm insmod vbe insmod loopback insmod iso9660 terminal_output gfxterm insmod jpeg background_image /boot/grub/grub.jpg setmenu_color_normal=white/black setmenu_color_highlight=black/light-gray set USBUUID=\u0026#34;306B-1C5B\u0026#34; menuentry \u0026#34;manjaro-kde-2012\u0026#34; --class manjaro{ set isofile=\u0026#34;/iso/manjaro-kde-20.1.2-201019-linux58.iso\u0026#34; set dri=\u0026#34;free\u0026#34; search --no-floppy -f --set=root $isofile probe -u $root --set=abc set pqr=\u0026#34;/dev/disk/by-uuid/$abc\u0026#34; loopback loop $isofile linux (loop)/boot/vmlinuz-x86_64 img_dev=$pqr img_loop=$isofile driver=$dri lang=zh_CN initrd (loop)/boot/intel_ucode.img (loop)/boot/initramfs-x86_64.img } menuentry \u0026#34;Ubuntu2004\u0026#34; { set isofile=\u0026#34;/iso/ubuntu-20.04.1-desktop-amd64.iso\u0026#34; loopback loop $isofile linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile locale=zh_CN.UTF-8 initrd (loop)/casper/initrd } menuentry \u0026#34;System shutdown\u0026#34; --class shutdown { echo \u0026#34;System shutting down...\u0026#34; halt } menuentry \u0026#34;System restart\u0026#34; --class restart { echo \u0026#34;System rebooting...\u0026#34; reboot }   "},{"id":8,"href":"/post/rvalue/","title":"å³å€¼å¼•ç”¨","section":"Posts","content":"å³å€¼å¼•ç”¨ #   ä½¿ç”¨\u0026amp;\u0026amp;è¡¨ç¤º åªèƒ½ç»‘å®šåˆ°ä¸€ä¸ªå°†è¦é”€æ¯çš„å¯¹è±¡ å·¦å€¼æŒä¹…ï¼Œå³å€¼çŸ­æš‚ å°†å·¦å€¼è½¬æ¢ä¸ºå¯¹åº”çš„å³å€¼ä½¿ç”¨std::move  1 2 3 4 5 6  int i = 42; int \u0026amp;r = i; //å·¦å€¼å¼•ç”¨ï¼Œok int \u0026amp;\u0026amp;rr = i; //é”™è¯¯ï¼Œä¸èƒ½æŠŠå³å€¼å¼•ç”¨ç»‘å®šåˆ°å·¦å€¼ä¸Š int \u0026amp;r2 = i*42; //é”™è¯¯ï¼Œi*42æ˜¯ä¸€ä¸ªå³å€¼ const int \u0026amp;r3 = i*42; //okï¼Œconstå¼•ç”¨å¯ä»¥ç»‘å®šåˆ°å³å€¼ int \u0026amp;\u0026amp;rr2 = i*42; //okï¼Œå³å€¼å¼•ç”¨ç»‘å®šå³å€¼   ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ #  ä¾‹å¦‚è¿™æ ·ä¸€ä¸ªç±»StrVecä¸­æœ‰ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ï¼Œä½¿ç”¨\u0026amp;\u0026amp;ä½œä¸ºå‚æ•°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132  // StrVec class, a class like vector but only store string as element // CppPrimer 13.5 // lcl 20190712  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;memory\u0026gt;using namespace std; class StrVec { public: StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr){} StrVec(const StrVec \u0026amp;); // copy constructor  StrVec(StrVec \u0026amp;\u0026amp;) noexcept; // move constructor  StrVec \u0026amp;operator=(const StrVec\u0026amp;); // copy assignment  StrVec \u0026amp;operator=(StrVec\u0026amp;\u0026amp;) noexcept; //move assignment  ~StrVec(); void push_back(const std::string\u0026amp;); size_t size() const {return first_free - elements;} size_t capacity() const {return cap - elements;} std::string *begin() const { return elements;} std::string *end() const { return first_free;} private: std::allocator\u0026lt;std::string\u0026gt; alloc; void chk_n_alloc() { if(size()==capacity()) reallocate(); } std::pair\u0026lt;std::string*, std::string*\u0026gt; alloc_n_copy (const std::string*, const std::string*); void free(); void reallocate(); std::string *elements; //point to first element  std::string *first_free; //point to first free element  std::string *cap; //point to rear; }; void StrVec::push_back(const string\u0026amp; s) { chk_n_alloc(); alloc.construct(first_free++, s); } pair\u0026lt;string*, string*\u0026gt; StrVec::alloc_n_copy(const string *b, const string* e) { auto data = alloc.allocate(e-b); return {data, uninitialized_copy(b,e,data)}; } void StrVec::free() { if(elements){ for(auto p = first_free; p!=elements;alloc.destroy(--p)); alloc.deallocate(elements, cap-elements); } } StrVec::StrVec(const StrVec\u0026amp;s) { auto newdata = alloc_n_copy(s.begin(), s.end()); elements = newdata.first; first_free = cap = newdata.second; } StrVec::~StrVec() { free(); } StrVec\u0026amp; StrVec::operator=(const StrVec \u0026amp;rhs) { // å…ˆåˆ†é…å¤§å°ç›¸åŒçš„å†…å­˜æ‹·è´ï¼Œå†é‡Šæ”¾æ‰åŸdata  auto data = alloc_n_copy(rhs.begin(), rhs.end()); free(); elements = data.first; first_free = cap = data.second; return *this; } void StrVec::reallocate() { auto newcapacity = size() ? 2 * size() : 1; auto newdata = alloc.allocate(newcapacity); auto dest = newdata; auto elem = elements; for( size_t i = 0; i!=size();++i) // ä½¿ç”¨äº†std::moveï¼Œä»è€Œä¼šè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°  alloc.construct(dest++,std::move(*elem++)); free(); elements = newdata; first_free = dest; cap = elements + newcapacity; } StrVec::StrVec(StrVec \u0026amp;\u0026amp;s) noexcept //ç§»åŠ¨æ“ä½œä¸æŠ›å‡ºä»»ä½•å¼‚å¸¸  :elements(s.elements), first_free(s.first_free), cap(s.cap) { // ä»¤sè¿›å…¥è¿™æ ·çš„çŠ¶æ€ï¼Œå¯¹å…¶è¿›è¡Œææ„æ˜¯å®‰å…¨çš„ï¼Ÿ  // è¿™é‡Œä»¤å…ƒç´ ä¸ºç©ºï¼Œææ„å‡½æ•°å°†ä¸èƒ½é‡Šæ”¾ç©ºé—´  // å› ä¸ºå…ƒç´ å·²ç»è½¬ç»™ç§»åŠ¨åçš„å¯¹è±¡ï¼Œç©ºé—´ä¸åº”è¯¥é‡Šæ”¾ï¼Œæ‰€ä»¥ä»¤ä»–ä»¬ä¸ºç©º  s.elements = s.first_free = s.cap = nullptr; } // ä½¿ç”¨noexceptå‘ŠçŸ¥ç¼–è¯‘å™¨ä¸ä¼šæŠ›å‡ºå¼‚å¸¸  StrVec\u0026amp; StrVec::operator=(StrVec \u0026amp;\u0026amp;rhs) noexcept { // å¤„ç†è‡ªèµ‹å€¼çš„æƒ…å†µ  if(this != \u0026amp;rhs){ free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; } } // test int main(int argc, char* argv[]) { StrVec sv,sv1; std::cout \u0026lt;\u0026lt; sv.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sv.capacity() \u0026lt;\u0026lt; std::endl; sv.push_back(\u0026#34;first line\u0026#34;); sv.push_back(\u0026#34;second_line\u0026#34;); sv1 = sv; std::cout \u0026lt;\u0026lt; sv1.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sv1.capacity() \u0026lt;\u0026lt; std::endl; }   "},{"id":9,"href":"/post/polymorphism/","title":"å¤šæ€ polymorphism","section":"Posts","content":"å¤šæ€ polymorphism #   ä¸€ä¸ªæ¥å£ï¼Œå¤šç§æ–¹æ³• ä½¿ç”¨è™šå‡½æ•°å®ç°  åŸºç±»æˆå‘˜å‡½æ•°æ·»åŠ äº†virtualå…³é”®å­—ï¼Œè¯¥å‡½æ•°åœ¨æ‰§è¡Œæ—¶ç»‘å®šã€‚å¦åˆ™åœ¨ç¼–è¯‘æ—¶ç»‘å®šã€‚æ‰€ä»¥\nåŸºç±»å¸Œæœ›å…¶æ´¾ç”Ÿç±»è¿›è¡Œè¦†ç›–çš„å‡½æ•°ï¼Œå®šä¹‰ä¸ºè™šå‡½æ•°\nä¾‹å­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; class Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;??\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat : public Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;Miao Miao\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog : public Animal{ public: void sound(){ cout \u0026lt;\u0026lt; \u0026#34;Wang Wang\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(int argc, char **argv){ Animal *animal; animal = new Cat; animal-\u0026gt;sound(); animal = new Dog; animal-\u0026gt;sound(); }   è¾“å‡º\n lcl@FX50JK:~/Documents/hub/learning-record/cpp$ ./polymorphism\n??\n??\n å¯è§animalæŒ‡é’ˆè™½ç„¶æŒ‡å‘å­ç±»Catå’ŒDogï¼Œä½†æ˜¯å¹¶æ²¡ç”¨ä»–ä»¬çš„soundæ–¹æ³•ã€‚åŸºç±»ä½¿ç”¨virtualå…³é”®å­—\n1 2 3 4 5 6  class Animal{ public: virtual void sound(){ cout \u0026lt;\u0026lt; \u0026#34;??\u0026#34; \u0026lt;\u0026lt; endl; } };   è¾“å‡º\n lcl@FX50JK:~/Documents/hub/learning-record/cpp$ ./polymorphism\nMiao Miao\nWang Wang\n"},{"id":10,"href":"/post/smartpointer/","title":"æ™ºèƒ½æŒ‡é’ˆ","section":"Posts","content":" #include \u0026lt;memory\u0026gt;\n ä¸‰ç§æ™ºèƒ½æŒ‡é’ˆ\nshared_ptr #  æœ‰å¼•ç”¨è®¡æ•°ï¼Œå½“æœ€åä¸€ä¸ªshared_ptrè¢«é”€æ¯ï¼Œå…¶æŒ‡å‘çš„å¯¹è±¡å°†è¢«ææ„ã€‚\nä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;iterator\u0026gt; using namespace std; class Foo{ public: Foo() {p = new int[10];cout \u0026lt;\u0026lt; \u0026#34;new@\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt;endl;} ~Foo() {cout \u0026lt;\u0026lt; \u0026#34;release@\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;delete [] p;p=nullptr;} int *p; }; void smartptr() { shared_ptr\u0026lt;Foo\u0026gt; sp1 = make_shared\u0026lt;Foo\u0026gt;(); auto sp2 = make_shared\u0026lt;Foo\u0026gt;(); } void ptr() { auto p = new Foo; } int main(int argc,char* argv[]) { smartptr(); ptr(); return 0; }   å…¶è¾“å‡ºç»“æœä¸º\n new@0x1001370 new@0x10013b8 release@0x10013b8 release@0x1001370 new@0x1001368\n make_shared\u0026lt;\u0026gt;æ˜¯åº“å‡½æ•°ï¼Œå°†ä¼šnewä¸€ä¸ªå¯¹è±¡ï¼Œç„¶åç»‘å®šåˆ°shared_ptr\n åœ¨å­å‡½æ•°smartpträ¸­ä¸¤ä¸ªä¸´æ—¶å˜é‡æ˜¯å…±äº«æŒ‡é’ˆï¼Œåœ¨é€€å‡ºå­å‡½æ•°æ—¶ä¼šè¢«é”€æ¯ï¼Œé”€æ¯æ—¶è°ƒç”¨äº†å¯¹è±¡çš„ææ„å‡½æ•°ã€‚ è€Œptrå‡½æ•°é‡Œåªæ˜¯æ™®é€šæŒ‡é’ˆï¼Œé€€å‡ºé”€æ¯æ—¶æ²¡æœ‰è°ƒç”¨ææ„å‡½æ•°ï¼Œé€ æˆå†…å­˜æ³„æ¼ã€‚  åˆ é™¤å™¨\nä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆè¿˜å¯ä»¥å®šä¹‰è‡ªå·±çš„é‡Šæ”¾æ“ä½œï¼Œè¿™æ˜¯é’ˆå¯¹é‚£äº›æ²¡æœ‰åˆé€‚ææ„å‡½æ•°çš„å¯¹è±¡æˆ–æ˜¯cè¯­è¨€çš„ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;memory\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; typedef int fd; fd fileid = 0; fd open() { cout \u0026lt;\u0026lt; \u0026#34;open \u0026#34; \u0026lt;\u0026lt; fileid \u0026lt;\u0026lt; endl; return fileid++; } void close(fd f) { cout \u0026lt;\u0026lt; \u0026#34;close \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; fileid--; } void end_fd(fd* f){close(*f);} void foo() { fd g = open(); shared_ptr\u0026lt;fd\u0026gt; sp(\u0026amp;g,end_fd); } int main(int argc, char *argv[]) { foo(); }   è¾“å‡º\n open 0 close 0\n éœ€è¦æ³¨æ„çš„æ˜¯ä¼ å…¥çš„åˆ é™¤å™¨å‡½æ•°çš„å‚æ•°å¿…é¡»æ˜¯æ™ºèƒ½æŒ‡é’ˆä¿å­˜çš„æŒ‡é’ˆç±»å‹æ‰å¯ä»¥é€šè¿‡ç¼–è¯‘ã€‚\nunique_ptr #  ä¸èƒ½æ‹·è´ï¼Œä¸èƒ½èµ‹å€¼ï¼Œæ‹¥æœ‰æŒ‡å‘çš„å¯¹è±¡\nå¯ä»¥ç›´æ¥åˆå§‹åŒ–\n1  unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;I am unique\u0026#34;))   1  unique_ptr\u0026lt;string\u0026gt; p2(p1); //é”™è¯¯ï¼Œä¸æ”¯æŒæ‹·è´   1 2  unique_ptr\u0026lt;string\u0026gt; p2; p2=p1;//é”™è¯¯ï¼Œä¸æ”¯æŒèµ‹å€¼   éœ€è¦è½¬ç§»æ§åˆ¶æƒçš„è¯ï¼Œå¯ä»¥ç”¨\n1  unique_ptr\u0026lt;string\u0026gt; p2(p1.release())   æˆ–è€…\n1 2  unique_ptr\u0026lt;string\u0026gt; p2; p2.reset(p1.release());   weak_ptr #  éœ€è¦ä¸€ä¸ªshared_ptræ¥åˆå§‹åŒ–å®ƒï¼Œä¸å½±å“shared_ptrçš„è®¡æ•°\n1  weak_ptr\u0026lt;T\u0026gt; wp(sp)   æ“ä½œ\n1 2 3 4  wp.reset() //ç½®ä¸ºç©º wp.use_count() //è¿”å›æŒ‡å‘å¯¹è±¡çš„shared_ptrçš„æ•°é‡ wp.expired() //wp.use_count()ä¸º0ï¼Œè¿”å›true wp.lock() //wp.expired()ä¸ºtrueï¼Œåˆ™è¿”å›ä¸€ä¸ªå…±äº«çš„shared_ptrï¼Œå¦åˆ™è¿”å›ä¸€ä¸ªç©ºçš„shared_ptr   weak_ptrçš„ä½œç”¨å°±æ˜¯è¾…åŠ©shared_ptrçš„ï¼Œæ¯”å¦‚è§£å†³shared_ptrç›¸äº’å¼•ç”¨çš„é—®é¢˜è€Œä¸èƒ½é‡Šæ”¾çš„é—®é¢˜ã€‚\n"},{"id":11,"href":"/post/docker1/","title":"docker1","section":"Posts","content":"åˆæ¢docker #  æˆ‘çš„centosæŒ‚æ‰äº†ï¼ŒæŠ˜è…¾äº†ä¸€ä¸¤å¤©æ²¡æœ‰æˆæ•ˆï¼Œæš‚æ—¶ä¸åšä»–æƒ³ï¼Œå¯èƒ½éœ€è¦é‡è£…äº†å§ã€‚ä¹‹å‰åœ¨win10ä¸Šç”¨VMwareï¼Œè€ç ´ç”µè„‘å¤ªå¡ï¼Œæœºç¼˜å·§åˆä¹‹ä¸‹ï¼Œæˆ‘äº†è§£åˆ°dockeræ˜¯è½»é‡çº§çš„è™šæ‹Ÿæœºï¼Œæ¥è¯•ä¸€ä¸‹ã€‚\nä¸‹è½½win10ç‰ˆæœ¬ï¼Œå®‰è£…åæœ‰Docker Desktopï¼Œä¸€çœ‹å†…å­˜å ç”¨ï¼Œå—¬ï¼Œæ»¡çš„ï¼Œåˆ«æ…Œï¼Œå…ˆsettingä¸€ä¸‹ Memoryå½“ç„¶é€‰æœ€å°ï¼ŒOKï¼Œå‹‰å¼ºå¯ä»¥ä½¿ç”¨äº†ã€‚ æ¥ä¸‹æ¥ï¼Œæ‰“å¼€cmdï¼Œå¼€å§‹dockerå†ç¨‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  C:\\Users\\Administrator\u0026gt;docker version Client: Docker Engine - Community Version: 18.09.2 API version: 1.39 Go version: go1.10.8 Git commit: 6247962 Built: Sun Feb 10 04:12:31 2019 OS/Arch: windows/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.2 API version: 1.39 (minimum version 1.12) Go version: go1.10.6 Git commit: 6247962 Built: Sun Feb 10 04:13:06 2019 OS/Arch: linux/amd64 Experimental: false   1 2 3  C:\\Users\\Administrator\u0026gt;docker search tutorial NAME DESCRIPTION STARS OFFICIAL AUTOMATED learn/tutorial 40   1 2 3 4 5 6  C:\\Users\\Administrator\u0026gt;docker pull learn/tutorial Using default tag: latest latest: Pulling from learn/tutorial 271134aeb542: Pull complete Digest: sha256:2933b82e7c2a72ad8ea89d58af5d1472e35dacd5b7233577483f58ff8f9338bd Status: Downloaded newer image for learn/tutorial:latest   1 2  C:\\Users\\Administrator\u0026gt;docker run learn/tutorial echo \u0026#34;hello world\u0026#34; hello world   ä¸€å¥—ç´ è´¨ä¸‰è¿ï¼Œå‡ºç°äº†classicalçš„hello world.\nä½¿ç”¨-itï¼Œå¯ä»¥å¾—åˆ°Linuxç»ˆç«¯ä½“éªŒï¼š -t è®©dockeråˆ†é…ä¸€ä¸ªä¼ªç»ˆç«¯ -i è®©å®¹å™¨çš„æ ‡å‡†è¾“å…¥ä¿æŒæ‰“å¼€\n1 2 3 4  C:\\Users\\Administrator\u0026gt;docker run -it learn/tutorial /bin/bash root@ce6e965e57f4:/# echo \u0026#34;Here is like a real bash\u0026#34; Here is like a real bash root@ce6e965e57f4:/#   "},{"id":12,"href":"/post/docker2/","title":"docker2","section":"Posts","content":"æ­å»ºå¼€å‘ç¯å¢ƒ #  é¦–å…ˆè¿˜æ˜¯ä»centoså…¥æ‰‹å§\n1 2 3  C:\\Users\\Administrator\u0026gt;docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 5221 [OK]   é€‰æ‹©ä¸€ä¸ªå®˜æ–¹çš„ç‰ˆæœ¬ï¼Œpullä¸‹æ¥\n1  docker run -it centos   è¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰vimï¼Œæ²¡æœ‰gccï¼Œæ²¡æœ‰gdbçš„ä¸–ç•Œï¼Œå®‰è£…ä»–ä»¬\n1 2 3  yum install vim yum install gcc yum install gdb   äºæ˜¯åœ¨windowsçš„dockerä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­æ„‰å¿«çš„codeäº†ã€‚\n\u0026ndash;ç„¶è€Œ å®æµ‹å‘ç°gdbä¸èƒ½ç”¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  [root@1bb163f86a43 lcl]# gdb hello GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-redhat-linux-gnu\u0026#34;. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;... Reading symbols from /lcl/hello...done. (gdb) l 1 #include \u0026lt;stdio.h\u0026gt; 2 3 int main() 4 { 5 printf(\u0026#34;hello world!\\n\u0026#34;); 6 return 0; 7 } (gdb) r Starting program: /lcl/hello warning: Error disabling address space randomization: Operation not permitted Cannot create process: Operation not permitted During startup program exited with code 127.   å‚è€ƒè¿™ç¯‡ https://blog.csdn.net/snipercai/article/details/80408569\n1 2 3  C:\\Users\\Administrator\u0026gt;docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1bb163f86a43 centos/gcc \u0026#34;/bin/bash\u0026#34; 45 minutes ago Exited (0) 16 minutes ago pensive_ramanujan   è®°ä½è¿™ä¸ªIDï¼Œcommitå®ƒ\n1 2 3 4 5 6 7 8 9  C:\\Users\\Administrator\u0026gt;docker commit 1bb develop sha256:30f0327ebe65560ebd78daf868c1835c0d97ee1c2ff95450ec1ebd848cb57cc7 C:\\Users\\Administrator\u0026gt;docker images REPOSITORY TAG IMAGE ID CREATED SIZE develop latest 30f0327ebe65 6 seconds ago 493MB centos/gcc latest f1af98e3ed8a 22 hours ago 408MB centos latest 1e1148e4cc2c 2 months ago 202MB learn/tutorial latest a7876479f1aa 5 years ago 128MB   ç°åœ¨å¾—åˆ°äº†images developï¼Œä»¥åå°±ç”¨å®ƒå§\n"},{"id":13,"href":"/post/docker3/","title":"docker3","section":"Posts","content":"dockerå®¹å™¨æ“ä½œ #  è®©æˆ‘ä»¬å†æ¢³ç†ä¸€éè¿™æ ·çš„äº‹å®ï¼šé•œåƒimageè¿è¡Œäº§ç”Ÿå®¹å™¨containerï¼Œé•œåƒå¯ä»¥ä¿å­˜ä¸ºé•œåƒ æŸ¥çœ‹å®¹å™¨\n1 2 3 4  C:\\WINDOWS\\system32\u0026gt;docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f3c6f9f95723 develop \u0026#34;/bin/bash\u0026#34; 27 hours ago Up 10 minutes modest_lovelace 5543700d2439 develop \u0026#34;/bin/bash\u0026#34; 7 days ago Exited (1) 6 days ago modest_edison   è¿è¡Œå®¹å™¨ï¼Œå¯ä»¥åªç®€å†™3ä¸ªå­—æ¯ä»£è¡¨ID\n1 2 3 4  C:\\WINDOWS\\system32\u0026gt;docker start f3c f3c C:\\WINDOWS\\system32\u0026gt;docker attach f3c   å¤šå¼€çª—å£\n1 2  C:\\Users\\Administrator\u0026gt;docker exec -it f3c bash [root@f3c6f9f95723 /]#   åˆ é™¤å®¹å™¨\n1 2  C:\\WINDOWS\\system32\u0026gt;docker rm a7f a7f   åˆ é™¤é•œåƒ\n1  docker rmi   "},{"id":14,"href":"/post/%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/","title":"ç©·ä¸¾æœç´¢","section":"Posts","content":"å®è´¨æ˜¯åˆ›å»ºä¸€ä¸ªçŠ¶æ€æ ‘ï¼Œè¾¹å»ºç«‹è¾¹å‰ªæï¼Œå¾—åˆ°æœ€ç»ˆçŠ¶æ€è¾“å‡º æ­¥éª¤æœ‰ï¼š\n åˆ—å‡ºè¡¨ç¤ºçŠ¶æ€çš„æ•°æ®ç»“æ„ åˆ—å‡ºåœ¨çŠ¶æ€ä¹‹é—´è¿ç§»çš„åŠ¨ä½œçš„æ•°æ®ç»“æ„ åˆ—å‡ºä¸¤ä¸ªçŠ¶æ€è½¬æ¢çš„æ‰€æœ‰åŠ¨ä½œåˆ—è¡¨ åˆ›å»ºä¸€ä¸ªdequeå­˜å‚¨æœç´¢çš„çŠ¶æ€ ä»dequeå°¾ç«¯å–å‡ºçŠ¶æ€ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯æœ€ç»ˆçŠ¶æ€ï¼Œæ˜¯çš„è¯æ‰“å°å½“å‰dequeï¼Œè¿›è¡Œæœç´¢searchï¼Œå¾ªç¯æ‰€æœ‰åŠ¨ä½œï¼Œæ‰§è¡ŒåŠ¨ä½œsearchOnOneAction åˆ¤æ–­æ–°çŠ¶æ€æ˜¯å¦æœ‰æ•ˆï¼Œæœ‰æ•ˆåˆ™åŠ å…¥dequeï¼Œç»§ç»­é€’å½’è°ƒç”¨æœç´¢  æœ‰å¾ˆå¤šé—®é¢˜ç”¨åˆ°ç©·ä¸¾æœç´¢ï¼Œæ¯”å¦‚è¿‡æ²³é—®é¢˜\n ä¸‰ä¸ªå’Œå°šå’Œä¸‰ä¸ªå¦–æ€ªè¿‡æ²³ èˆ¹åªèƒ½è½½ä¸¤ä¸ª ä»»ä½•æ—¶å€™åªè¦å¦–æ€ªæ•°é‡å¤§äºå’Œå°šæ•°é‡ å¦–æ€ªå°±è¦åƒæ‰å’Œå°š æ±‚è§£è¿‡æ²³æ–¹æ¡ˆ\n è¿™ä¸ªé—®é¢˜é¦–å…ˆç¡®å®šçŠ¶æ€çš„æ•°æ®ç»“æ„ï¼ŒçŠ¶æ€å°±æ˜¯ä¸¤å²¸monkå’Œmonsterçš„æ•°é‡ï¼ŒåŒæ—¶æœ‰ä¸€äº›é…å¥—æ“ä½œ\n åˆ¤æ–­æ˜¯å¦æ˜¯æœ€ç»ˆçŠ¶æ€ çŠ¶æ€è¿ç§» åˆ¤æ–­çŠ¶æ€æ˜¯å¦æœ‰æ•ˆ  1 2 3 4 5 6 7 8 9 10 11 12 13  class ItemState{ friend\tostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp;, const ItemState\u0026amp;); public: bool operator==(const ItemState\u0026amp;); bool isFinalState(); bool takeAction(ItemState\u0026amp; next, const ACTION_EFFECTION\u0026amp; action); bool isValid(); int local_monster; int local_monk; int remote_monster; int remote_monk; BOAT_LOCATION boat; };   åŠ¨ä½œæœ‰å¦‚ä¸‹å®šä¹‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  typedef enum{ ONE_MONSTER_GO = 0, TWO_MONSTER_GO, ONE_MONK_GO, TWO_MONK_GO, ONR_MONSTER_ONE_MONK_GO, ONE_MONSTER_BACK, TWO_MONSTER_BACK, ONE_MONK_BACK, TWO_MONK_BACK, ONR_MONSTER_ONE_MONK_BACK, INVALID_ACTION_NAME, }ACTION_NAME;\ttypedef struct{ ACTION_NAME act; BOAT_LOCATION boat_to; int move_monster; int move_monk; }ACTION_EFFECTION;   å¾—åˆ°actionçš„åˆ—è¡¨ï¼Œä½œä¸ºç©·ä¸¾çš„ä¾æ®\n1 2 3 4 5 6 7 8 9 10 11 12 13  static ACTION_EFFECTION actEffect[] = { {ONE_MONSTER_GO, REMOTE, -1, 0}, {TWO_MONSTER_GO, REMOTE,\t-2,\t0}, {ONE_MONK_GO,\tREMOTE,\t0,\t-1}, {TWO_MONK_GO,\tREMOTE,\t0,\t-2}, {ONR_MONSTER_ONE_MONK_GO,\tREMOTE,\t-1,\t-1}, {ONE_MONSTER_BACK,\tLOCAL,\t1,\t0}, {TWO_MONSTER_BACK,\tLOCAL,\t2,\t0}, {ONE_MONK_BACK,\tLOCAL,\t0,\t1}, {TWO_MONK_BACK,\tLOCAL,\t0,\t2}, {ONR_MONSTER_ONE_MONK_BACK,\tLOCAL,\t1,\t1} };   æœç´¢æ—¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  void searchState(deque\u0026lt;ItemState\u0026gt; \u0026amp;states) { int act; ItemState current = states.back(); if(current.isFinalState()) { printResult(states); return; } for(act = 0; act \u0026lt; INVALID_ACTION_NAME; act++) { //debug_out \u0026lt;\u0026lt; act \u0026lt;\u0026lt;endl; \tsearchStateOnOneAction(states, current, actEffect[act]); } } void searchStateOnOneAction(deque\u0026lt;ItemState\u0026gt; \u0026amp;states, ItemState \u0026amp;current, ACTION_EFFECTION\u0026amp; actEff) { ItemState next; bool canTackAction; canTackAction = current.takeAction(next, actEff); //debug_out \u0026lt;\u0026lt; next; \tif(canTackAction \u0026amp;\u0026amp; !isProcessed(states, next)) { //debug_out \u0026lt;\u0026lt; \u0026#34;valid\u0026#34; \u0026lt;\u0026lt; endl; \t// printResult(states); \tstates.push_back(next); searchState(states); states.pop_back(); } }   ä¸¤ä¸ªå‡½æ•°èµ·åˆ°äº†é€’å½’çš„ä½œç”¨ï¼ŒåŒæ—¶ä½¿ç”¨dequeé¿å…å‡ºç°ç¯è·¯\n1 2 3 4 5 6  bool isProcessed(deque\u0026lt;ItemState\u0026gt; \u0026amp;states, ItemState\u0026amp; state) { auto it = states.end(); it = find_if(states.begin(), states.end(), [\u0026amp;](ItemState\u0026amp; s){return s==state;}); return(it!=states.end()); }   å®Œæ•´ä»£ç è§https://github.com/lclei/algorithm_fun/tree/master/MonkAndMonster\næœ€åçš„æ‰¾åˆ°äº†å››ç§æ–¹æ¡ˆ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195  o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 3o || 0o 1x || 2x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 0o || 3o 2x || 1x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 3o || 0o 1x || 2x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 1o || 2o 1x || 2x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 2o || 1o 2x || 1x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 0o || 3o 2x || 1x boat|| 0o || 3o 0x || 3x ||boat o stands for monk, and x stands for monster. 3o || 0o 3x || 0x boat|| 2o || 1o 2x || 1x ||boat 3o || 0o 2x || 1x boat|| 3o || 0o 0x || 3x ||boat 3o || 0o 1x || 2x boat|| 1o || 2o 1x || 2x ||boat 2o || 1o 2x || 1x boat|| 0o || 3o 2x || 1x ||boat 0o || 3o 3x || 0x boat|| 0o || 3o 1x || 2x ||boat 1o || 2o 1x || 2x boat|| 0o || 3o 0x || 3x ||boat   "},{"id":15,"href":"/post/wbcurrency/","title":"å¹¶å‘æœåŠ¡å™¨","section":"Posts","content":" forkè¿›ç¨‹ IOå¤ç”¨ çº¿ç¨‹   å¤šè¿›ç¨‹ #  ä¸»è¿›ç¨‹ç›‘å¬ï¼Œåœ¨å¾ªç¯ä¸­æ¥å—è¿æ¥è¯·æ±‚ï¼Œå½“è¿æ¥å»ºç«‹åï¼Œforkä¸€ä¸ªå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­è¿›è¡Œå¤„ç†ã€‚\n  ä¸»è¿›ç¨‹ï¼šlisten -\u0026gt; while(1) -\u0026gt; accept -\u0026gt; fork -\u0026gt; close connfd\n  å­è¿›ç¨‹ï¼šclose listenfd -\u0026gt; handle -\u0026gt; close connfd\n  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverfork 6667 Parent: waitting\u0026hellip; name[localhost] port[38276]connected! Child No.1 will handle it! Parent: waitting\u0026hellip; server recived 6 bytes name[localhost] port[38280]connected! Child No.2 will handle it! Parent: waitting\u0026hellip; server recived 7 bytes\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 first first\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 second second\n code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void echo(int connfd); void sigchld_handler(int sig) { while(waitpid(-1,0,WNOHANG) \u0026gt;0) ; return; } int main(int argc, char **argv) { int listenfd, connfd, cno=1; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } signal(SIGCHLD, sigchld_handler); listenfd = open_listenfd(argv[1]); while(1){ printf(\u0026#34;Parent: waitting...\\n\u0026#34;); clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); printf(\u0026#34;name[%s] port[%s]connected! Child No.%d will handle it!\\n\u0026#34;, client_hostname,client_port,cno++); if(fork()==0) //child \t{ close(listenfd); echo(connfd); close(connfd); exit(0); } close(connfd); } exit(0); } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes\\n\u0026#34;,(int)n); write(connfd,buf,n); } } Â© 2019 GitHub, Inc.    IOå¤ç”¨ #  IOå¤ç”¨å³ä½¿ç”¨selectå‡½æ•°\n #include \u0026lt;sys/select.h\u0026gt; int select(int n, fd_set *fdset, NULL, NULL, NULL) //ç­‰å¾…ä¸€ç»„æè¿°ç¬¦å‡†å¤‡å¥½è¯» FD_ZERO(fd_set *fdset); FD_CLR(int fd, fd_set *fdset); FD_SET(int fd, fd_set *fdset); FD_ISSET(int fd, fd_set *fdset);\n stdioä¸connfdçš„å¤ç”¨ #  å¦‚æœä½¿ç”¨echoserverè¿­ä»£ç‰ˆæœ¬çš„åŒæ—¶ï¼Œè¦æ±‚èƒ½å¤Ÿå“åº”æœåŠ¡å™¨æœ¬èº«çš„stdinè¾“å…¥ï¼Œåˆ™å¯ä»¥ä½¿ç”¨selectã€‚ä¸€ä¸ªæ ‡å‡†è¾“å…¥çš„fdä¸€èˆ¬æ˜¯0ï¼Œç›‘å¬fdåˆ™æ˜¯ç³»ç»Ÿåˆ†é…\n å°†stdinå’ŒllistenfdåŠ å…¥fdset ä½¿ç”¨selectç­‰å¾…æ˜¯å¦æœ‰fdå‡†å¤‡å¥½ é€šè¿‡FD_ISSETæŸ¥çœ‹å“ªä¸ªå‡†å¤‡å¥½å¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void echo(int connfd); void command(void); int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; fd_set read_set, ready_set; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); FD_ZERO(\u0026amp;read_set);\t//clear read_set \tFD_SET(STDIN_FILENO, \u0026amp;read_set);\t//add stdin to read_set \tFD_SET(listenfd,\u0026amp;read_set);\t//add listenfd to read_set  while(1){ ready_set = read_set; select(listenfd+1,\u0026amp;ready_set,NULL,NULL,NULL); if(FD_ISSET(STDIN_FILENO,\u0026amp;ready_set)) { printf(\u0026#34;stdin is ready.\\n\u0026#34;); command(); } if(FD_ISSET(listenfd,\u0026amp;ready_set)){ printf(\u0026#34;client connetted.\\n\u0026#34;); clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); echo(connfd); close(connfd); } } exit(0); } void command(void){ char buf[MAXLINE]; if(!fgets(buf,MAXLINE,stdin)){ exit(0);\t//EOF \t} printf(\u0026#34;%s\u0026#34;,buf); } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes\\n\u0026#34;,(int)n); write(connfd,buf,n); } }   server behavior:\n [root@linuxkit-00155ddc0103 inet]# ./select 6667 do something stdin is ready. do something hello stdin is ready. hello client connetted. server recived 12 bytes ccd //no response here becuse client is connecting stdin is ready. //client close now ccd f stdin is ready. f stdin is ready. //ctrl+D here\n client behavior:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 i am client i am client\n åŸºäºI/Oå¤šè·¯å¤ç”¨çš„å¹¶å‘äº‹ä»¶é©±åŠ¨å™¨ #  ä¸ä¹‹å‰ç±»ä¼¼ï¼Œç»´æŠ¤ä¸€ä¸ªç»“æ„ä½“poolï¼Œå­˜å‚¨readsetï¼Œreadysetå’Œclientfd\n serverç›‘å¬ï¼Œåˆå§‹åŒ–pool è¿›å…¥å¾ªç¯ï¼Œåˆå§‹åŒ–readysetï¼Œselecté˜»å¡ï¼Œç­‰å¾…fdå‡†å¤‡å¥½ è‹¥listenfdï¼Œæ·»åŠ client å¯¹æ‰€æœ‰å‡†å¤‡å¥½çš„clientfdå›å°„æœåŠ¡  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverselect 6667 localhost:38334 connected! Server recived 5 (5 total) bytes on fd 4 Server recived 4 (9 total) bytes on fd 4 Server recived 7 (16 total) bytes on fd 4 localhost:38338 connected! Server recived 4 (20 total) bytes on fd 5 Server recived 6 (26 total) bytes on fd 5 Server recived 2 (28 total) bytes on fd 5 Close connfd 4 Server recived 7 (35 total) bytes on fd 5 Close connfd 5\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 1234 1234 123 123 123456 123456 [root@linuxkit-00155ddc0103 inet]#\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 123 123 12345 12345 1 1 123456 123456 [root@linuxkit-00155ddc0103 inet]#\n code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026#34;mynet.h\u0026#34;typedef struct{ int maxfd; fd_set read_set; fd_set ready_set; int nready; int maxi; int clientfd[FD_SETSIZE]; }pool; void add_client(int connfd, pool *p); void check_clients(pool *p); void init_pool(int listenfd, pool *p); int open_listenfd(char *port); int byte_cnt = 0; int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; static pool pool; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); init_pool(listenfd,\u0026amp;pool); while(1){ pool.ready_set = pool.read_set; pool.nready = select(pool.maxfd+1,\u0026amp;pool.ready_set,NULL,NULL,NULL); if(FD_ISSET(listenfd,\u0026amp;pool.ready_set)) { clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); printf(\u0026#34;%s:%s connected!\\n\u0026#34;,client_hostname,client_port); add_client(connfd, \u0026amp;pool); } check_clients(\u0026amp;pool); } exit(0); } void init_pool(int listenfd, pool *p){ int i; p-\u0026gt;maxi = -1; for(i=0;i\u0026lt;FD_SETSIZE;i++) p-\u0026gt;clientfd[i] = -1; p-\u0026gt;maxfd = listenfd; FD_ZERO(\u0026amp;p -\u0026gt; read_set); FD_SET(listenfd, \u0026amp;p-\u0026gt;read_set); } void add_client(int connfd, pool *p){ int i; p-\u0026gt;nready--; for(i=0;i\u0026lt;FD_SETSIZE;i++){ if(p-\u0026gt;clientfd[i]\u0026lt;0){ p-\u0026gt;clientfd[i] = connfd; FD_SET(connfd,\u0026amp;p-\u0026gt;read_set); if(connfd,\u0026amp;p-\u0026gt;maxfd) p-\u0026gt;maxfd = connfd; if(i\u0026gt;p-\u0026gt;maxi) p-\u0026gt;maxi = i; break; } if(i == FD_SETSIZE) printf(\u0026#34;Add client error! Beyond max client numbers.\\n\u0026#34;); } } void check_clients(pool *p) { int i,connfd,n; char buf[MAXLINE]; char echostr[MAXLINE+10]; for(i=0;(i\u0026lt;=p-\u0026gt;maxi)\u0026amp;\u0026amp;(p-\u0026gt;nready\u0026gt;0);i++){ connfd = p-\u0026gt;clientfd[i]; sprintf(buf,\u0026#34;\\0\u0026#34;); if((connfd\u0026gt;0)\u0026amp;\u0026amp;(FD_ISSET(connfd,\u0026amp;p-\u0026gt;ready_set))){ p-\u0026gt;nready--; if((n=read(connfd,buf,MAXLINE))!=0){ byte_cnt+=n; printf(\u0026#34;Server recived %d (%d total) bytes on fd %d\\n\u0026#34;,n,byte_cnt,connfd); write(connfd,buf,n); } else{ printf(\u0026#34;Close connfd %d\\n\u0026#34;,connfd); close(connfd); FD_CLR(connfd,\u0026amp;p-\u0026gt;read_set); p-\u0026gt;clientfd[i] = -1; } } } }    å¤šçº¿ç¨‹ #  server:\n [root@linuxkit-00155ddc0103 inet]# ./echoserverthread 6667 name[localhost] port[38362]connected! Thread id:140562122241792 will serve it! name[localhost] port[38366]connected! Thread id:140562113849088 will serve it! server recived 6 bytes from fd 4 server recived 4 bytes from fd 4 server recived 7 bytes from fd 5 server recived 4 bytes from fd 5\n client1:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667\n12345 12345 123 123\n client2:\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 654321 654321 321 321\n æ³¨æ„ä¼ é€’connfdæ—¶æ˜¯æ–°ç”³è¯·ç©ºé—´ï¼Œå¹¶åœ¨threadé‡Œé‡Šæ”¾ code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026#34;mynet.h\u0026#34;int open_listenfd(char *port); void *thread(void *vargp); void echo(int connfd); int main(int argc, char **argv) { int listenfd, *connfdp, cno=1; socklen_t clientlen; pthread_t tid; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); while(1){ clientlen = sizeof(struct sockaddr_storage); connfdp = malloc(sizeof(int)); *connfdp = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); pthread_create(\u0026amp;tid,NULL,thread,connfdp); printf(\u0026#34;name[%s] port[%s]connected! Thread id:%ld will serve it!\\n\u0026#34;, client_hostname,client_port,(unsigned long long)tid); } exit(0); } void *thread(void* vargp){ int connfd = *((int *)vargp); pthread_detach(pthread_self()); free(vargp); echo(connfd); close(connfd); return NULL; } void echo(int connfd) { size_t n; char buf[MAXLINE]; while((n=read(connfd,buf,MAXLINE))!=0){ printf(\u0026#34;server recived %d bytes from fd %d\\n\u0026#34;,(int)n,connfd); write(connfd,buf,n); } }   åŸºäºçº¿ç¨‹çš„äº‹ä»¶é©±åŠ¨ç¨‹åº #  ä¹Ÿç§°ä½œé¢„çº¿ç¨‹åŒ–çš„æ–¹æ³•\n ä¸»çº¿ç¨‹å°†è¿æ¥ç¬¦connfdæ”¾å…¥æ± ä¸­ å·¥ä½œçº¿ç¨‹å°†connfdå–å‡ºå¹¶å¤„ç† åŠ å…¥çº¿ç¨‹å’Œå–å‡ºçº¿ç¨‹éƒ½ä½¿ç”¨äº’æ–¥é‡ä¿æŠ¤ echoç¨‹åºä¸­çš„cntä¹Ÿä½¿ç”¨äº’æ–¥é‡ä¿æŠ¤  server\n [root@linuxkit-00155ddc0103 inet]# ./echoserver_pre_thread 6667 client[localhost:38376] connected! connfd 4! server recived 7 (7 total) bytes on fd 4 client[localhost:38380] connected! connfd 5! server recived 9 (16 total) bytes on fd 5 server recived 4 (20 total) bytes on fd 4\n client1\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 123456 123456 123 123\n client2\n [root@linuxkit-00155ddc0103 inet]# ./echoclient localhost 6667 87654321 87654321\n sbuf.c fdæ± ï¼Œæ’å…¥ï¼Œå–å‡ºæ“ä½œ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026#34;sbuf.h\u0026#34; void sbuf_init(sbuf_t *sp, int n){ sp-\u0026gt;buf = calloc(n, sizeof(int)); sp-\u0026gt;n = n; sp-\u0026gt;front = sp-\u0026gt;rear = 0; sem_init(\u0026amp;sp-\u0026gt;mutex,0,1); sem_init(\u0026amp;sp-\u0026gt;slots,0,n); sem_init(\u0026amp;sp-\u0026gt;items,0,0); } void snuf_deinit(sbuf_t *sp){ free(sp-\u0026gt;buf); } void sbuf_insert(sbuf_t *sp, int item){ sem_wait(\u0026amp;sp-\u0026gt;slots); sem_wait(\u0026amp;sp-\u0026gt;mutex); sp-\u0026gt;buf[(++sp-\u0026gt;rear)%(sp-\u0026gt;n)] = item; sem_post(\u0026amp;sp-\u0026gt;mutex); sem_post(\u0026amp;sp-\u0026gt;items); } int sbuf_remove(sbuf_t *sp){ int item; sem_wait(\u0026amp;sp-\u0026gt;items); sem_wait(\u0026amp;sp-\u0026gt;mutex); item = sp-\u0026gt;buf[(++sp-\u0026gt;front)%(sp-\u0026gt;n)]; sem_post(\u0026amp;sp-\u0026gt;mutex); sem_post(\u0026amp;sp-\u0026gt;slots); return item; }   sbufç»“æ„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #ifndef SBUF_H_ #define SBUF_H_ #include \u0026#34;mynet.h\u0026#34;#include \u0026lt;semaphore.h\u0026gt; typedef struct { int *buf; int n; int front; int rear; sem_t mutex; sem_t slots; sem_t items; }sbuf_t; void dbuf_init(sbuf_t *sp, int n); void sbuf_deinit(sbuf_t *p); void sbuf_insert(sbuf_t *sp, int item); int sbuf_remove(sbuf_t *sp); #endif   echo_cnt.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026#34;echo_cnt.h\u0026#34; static int byte_cnt; static sem_t mutex; static void init_echo_cnt(void){ sem_init(\u0026amp;mutex,0,1); byte_cnt = 0; } void echo_cnt(int connfd){ int n; char buf[MAXLINE]; static pthread_once_t once = PTHREAD_ONCE_INIT; pthread_once(\u0026amp;once, init_echo_cnt); while((n=read(connfd,buf,MAXLINE))!=0){ sem_wait(\u0026amp;mutex); byte_cnt += n; printf(\u0026#34;server recived %d (%d total) bytes on fd %d\\n\u0026#34;, n,byte_cnt,connfd); sem_post(\u0026amp;mutex); write(connfd,buf,n); } }   ä¸»ç¨‹åº\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include \u0026#34;mynet.h\u0026#34;#include \u0026#34;sbuf.h\u0026#34;#include \u0026#34;echo_cnt.h\u0026#34;#define NTHREADS 4 #define SBUFSIZE 16  int open_listenfd(char *port); void *thread(void *vargp); sbuf_t sbuf; int main(int argc, char **argv) { int listenfd, connfd, i; socklen_t clientlen; pthread_t tid; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if(argc!=2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(0); } listenfd = open_listenfd(argv[1]); sbuf_init(\u0026amp;sbuf,SBUFSIZE); for(i = 0;i\u0026lt;NTHREADS;i++){ pthread_create(\u0026amp;tid,NULL,thread,NULL); } while(1){ clientlen = sizeof(struct sockaddr_storage); connfd = accept(listenfd, (SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAXLINE,0); sbuf_insert(\u0026amp;sbuf,connfd); printf(\u0026#34;client[%s:%s] connected! connfd %d!\\n\u0026#34;, client_hostname,client_port,(int)connfd); } exit(0); } void *thread(void* vargp){ pthread_detach(pthread_self()); while(1){ int connfd = sbuf_remove(\u0026amp;sbuf); echo_cnt(connfd); close(connfd); } return NULL; }   "},{"id":16,"href":"/post/webserver/","title":"webæœåŠ¡å™¨","section":"Posts","content":"é¦–å…ˆåˆ›å»ºå‡ ä¸ªå‡½æ•°ä»¥æ–¹ä¾¿æˆ‘ä»¬è°ƒç”¨\n open_clinetfd: åˆ›å»ºä¸€ä¸ªç½‘ç»œsocketï¼Œä½œä¸ºå®¢æˆ·ç«¯ï¼Œå¹¶ä¸”å°è¯•è¿æ¥ä¸»æœº open_listenfd: åˆ›å»ºsocketï¼Œä½œä¸ºä¸»æœºï¼Œå¹¶å¼€å§‹ç›‘å¬  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026#34;mynet.h\u0026#34; int open_clientfd(char *hostname, char *port){ int clientfd; struct addrinfo hints, *listp, *p; memset(\u0026amp;hints, 0,sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_NUMERICSERV; hints.ai_flags |= AI_ADDRCONFIG; getaddrinfo(hostname, port, \u0026amp;hints, \u0026amp;listp); for(p=listp;p;p=p-\u0026gt;ai_next){ if((clientfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype,p-\u0026gt;ai_protocol))\u0026lt;0) continue; if(connect(clientfd,p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen)!=-1) break; close(clientfd); } freeaddrinfo(listp); if(!p) return -1; else return clientfd; } int open_listenfd(char *port) { struct addrinfo hints, *listp, *p; int listenfd, optval=1; memset(\u0026amp;hints, 0 ,sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; hints.ai_flags |= AI_NUMERICSERV; getaddrinfo(NULL, port, \u0026amp;hints, \u0026amp;listp); for(p=listp;p;p=p-\u0026gt;ai_next){ if((listenfd = socket(p-\u0026gt;ai_family,p-\u0026gt;ai_socktype,p-\u0026gt;ai_protocol)) \u0026lt; 0) continue; setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,(const void *)\u0026amp;optval,sizeof(int)); if(bind(listenfd,p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen)==0) break; //success \tclose(listenfd); //bind fail, try next \t} freeaddrinfo(listp); if(!p) return -1; if(listen(listenfd,LISTENQ)\u0026lt;0){ close(listenfd); return -1; } return listenfd; }   æˆ‘ä»¬çš„æœåŠ¡å™¨æœ‰ä»¥ä¸‹å‡ ä¸ªæ¨¡å—\n int main(int argc, char** argv)ï¼šä»shellè¯»å–å‚æ•°ä½œä¸ºç«¯å£ï¼Œä½¿ç”¨ä¸Šè¿°open_listenfdåˆ›å»ºä¸€ä¸ªç›‘å¬ç«¯å£ï¼Œä½¿ç”¨acceptåˆ›å»ºä¸€ä¸ªè¿æ¥ï¼Œè¿›å…¥do_itå¼€å§‹å¤„ç†äº‹åŠ¡ void doit(int fd)ï¼šdo_itçš„å‚æ•°æ˜¯connfdï¼Œè¯»å–è¯·æ±‚ï¼Œè°ƒç”¨parse_uriåˆ†æè¯·æ±‚æ˜¯é™æ€è¯·æ±‚è¿˜æ˜¯åŠ¨æ€è¯·æ±‚ï¼Œåˆ†åˆ«è°ƒç”¨serve_staticå’Œserve_dynamicè¿›è¡Œå“åº” int parse_uri(char *uri, char *filename, char *cgiargs)ï¼šurlä¸åŒ…å«cgi-binåˆ™è®¤ä¸ºæ˜¯é™æ€è¯·æ±‚ï¼Œè¯»å–è¯·æ±‚çš„æ–‡ä»¶ï¼Œè‹¥æ²¡æœ‰ï¼Œé»˜è®¤è¿”å›home.htmlï¼›å¦åˆ™è®¤ä¸ºæ˜¯åŠ¨æ€è¯·æ±‚ void serve_static(int fd, char *filename, int filesize)ï¼šå‘é€headerï¼Œå†å‘é€æ–‡ä»¶ void serve_dynamic(int fd, char *filename, char *cgiargs)ï¼šæœåŠ¡åŠ¨æ€å†…å®¹ï¼Œåœ¨cgi-binæ‰¾è¿è¡Œç¨‹åº  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173  #include \u0026#34;mynet.h\u0026#34; void doit(int fd); void read_requesthdrs(int fd); int parse_uri(char *uri, char *filename, char *cgiargs); void serve_static(int fd, char *filename, int filesize); void get_filetype(char *filename, char *filetype); void serve_dynamic(int fd, char *filename, char *cgiargs); void clienterror(int fd, char*cause, char *errnum, char *shortmsg, char *longmsg); int main(int argc, char** argv) { int listenfd,connfd; char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; if(argc!=2){ fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;,argv[0]); exit(1); } listenfd = open_listenfd(argv[1]); while(1){ clientlen = sizeof(clientaddr); connfd = accept(listenfd,(SA*)\u0026amp;clientaddr,\u0026amp;clientlen); getnameinfo((SA*)\u0026amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,0); printf(\u0026#34;Accepted connection from (%s, %s)\\n\u0026#34;,hostname,port); doit(connfd); close(connfd); } } void doit(int fd){ int is_static; struct stat sbuf; char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE]; char filename[MAXLINE], cgiargs[MAXLINE]; read(fd, buf, MAXLINE); printf(\u0026#34;Requset hears:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;,buf); sscanf(buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); if(strcasecmp(method, \u0026#34;GET\u0026#34;)){ clienterror(fd, method, \u0026#34;501\u0026#34;, \u0026#34;Not implementedd\u0026#34;,\u0026#34;Tiny does not implement this method\u0026#34;); return; } //read_requesthdrs(fd); \tis_static = parse_uri(uri,filename,cgiargs); if(stat(filename,\u0026amp;sbuf)\u0026lt;0){ clienterror(fd, filename, \u0026#34;404\u0026#34;, \u0026#34;Not found\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t find this file\u0026#34;); return; } if(is_static){ if(!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR \u0026amp; sbuf.st_mode)){ clienterror(fd, filename, \u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t read the file\u0026#34;); return; } serve_static(fd,filename,sbuf.st_size); } else { if(!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR \u0026amp; sbuf.st_mode)){ clienterror(fd, filename, \u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;Tiny couldn\u0026#39;t run the CGI program\u0026#34;); return; } serve_dynamic(fd,filename,cgiargs); } } void read_requesthdrs(int fd){ char buf[MAXLINE]; read(fd,buf,MAXLINE); while(strcmp(buf, \u0026#34;\\r\\n\u0026#34;)){ read(fd,buf,MAXLINE); printf(\u0026#34;%s\u0026#34;,buf); } return; } int parse_uri(char *uri, char *filename, char *cgiargs){ char *ptr; if(!strstr(uri, \u0026#34;cgi-bin\u0026#34;)) { strcpy(cgiargs,\u0026#34;\u0026#34;); strcpy(filename,\u0026#34;.\u0026#34;); strcat(filename,uri); if(uri[strlen(uri)-1] == \u0026#39;/\u0026#39;) strcat(filename,\u0026#34;home.html\u0026#34;); return 1; } else{\t//dynammic content \tptr = index(uri,\u0026#39;?\u0026#39;); if (ptr) { strcpy(cgiargs, ptr+1); *ptr = \u0026#39;\\0\u0026#39;; } else strcpy(cgiargs, ptr+1); strcpy(filename,\u0026#34;.\u0026#34;); strcat(filename,uri); return 0; } } void serve_static(int fd, char *filename, int filesize){ int srcfd; char *srcp, filetype[MAXLINE], buf[MAXLINE*10]; get_filetype(filename, filetype); sprintf(buf, \u0026#34;HTTP/1.0 200 OK\\r\\n\u0026#34;); sprintf(buf, \u0026#34;%sServer: Tiny Web Server\\r\\n\u0026#34;,buf); sprintf(buf, \u0026#34;%sConnection: close\\r\\n\u0026#34;,buf); sprintf(buf, \u0026#34;%sContent-length: %d\\r\\n\u0026#34;,buf,filesize); sprintf(buf, \u0026#34;%sContent-type: %s\\r\\n\\r\\n\u0026#34;,buf,filetype); write(fd,buf,strlen(buf)); printf(\u0026#34;Response headers:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;,buf); srcfd = open(filename,O_RDONLY, 0); srcp = mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); close(srcfd); write(fd,srcp,filesize); munmap(srcp,filesize); } void get_filetype(char *filename, char *filetype){ if(strstr(filename,\u0026#34;.html\u0026#34;)) strcpy(filetype, \u0026#34;text/html\u0026#34;); else if (strstr(filename,\u0026#34;.gif\u0026#34;)) strcpy(filetype, \u0026#34;image/gif\u0026#34;); else if (strstr(filename,\u0026#34;.png\u0026#34;)) strcpy(filetype, \u0026#34;image/png\u0026#34;); else if (strstr(filename,\u0026#34;.jpg\u0026#34;)) strcpy(filetype, \u0026#34;image/jpeg\u0026#34;); else strcpy(filetype, \u0026#34;image/plain\u0026#34;); } void serve_dynamic(int fd, char *filename, char *cgiargs){ char buf[MAXLINE],*emptylist[] = {NULL}; sprintf(buf,\u0026#34;HTTP/1.0 200 OK\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); sprintf(buf,\u0026#34;Server: Tiny Web Server\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); if(fork()==0) { setenv(\u0026#34;QUERY_STRING\u0026#34;,cgiargs,1); dup2(fd,STDOUT_FILENO); execve(filename,emptylist,environ); } wait(NULL); } void clienterror(int fd, char*cause, char *errnum, char *shortmsg, char *longmsg){ char buf[MAXLINE], body[100*MAXLINE]; sprintf(body,\u0026#34;\u0026lt;html\u0026gt;\u0026lt;title\u0026gt;Tiny Error\u0026lt;/title\u0026gt;\u0026#34;); sprintf(body,\u0026#34;%s\u0026lt;body bgcolor=\u0026#34;\u0026#34;ffffff\u0026#34;\u0026#34;\u0026gt;\\r\\n\u0026#34;,body); sprintf(body,\u0026#34;%s%s: %s\\r\\n\u0026#34;,body,errnum,shortmsg); sprintf(body,\u0026#34;%s\u0026lt;p\u0026gt;%s: %s\\r\\n\u0026#34;,body,longmsg,cause); sprintf(body,\u0026#34;%s\u0026lt;hr\u0026gt;\u0026lt;em\u0026gt;The Tiny Web server\u0026lt;/em\u0026gt;\\r\\n\u0026#34;,body); sprintf(buf, \u0026#34;HTTP/1.0 %s %s\\r\\n\u0026#34;,errnum,shortmsg); write(fd,buf,strlen(buf)); sprintf(buf, \u0026#34;Content-type: text/html\\r\\n\u0026#34;); write(fd,buf,strlen(buf)); sprintf(buf, \u0026#34;Content-length: %d\\r\\n\\r\\n\u0026#34;,(int)strlen(body)); write(fd,buf,strlen(buf)); write(fd,body,strlen(body)); }   "},{"id":17,"href":"/post/daemon/","title":"å®ˆæŠ¤è¿›ç¨‹","section":"Posts","content":"å®ˆæŠ¤è¿›ç¨‹ #   ç”Ÿå­˜æœŸé•¿ï¼Œå¸¸å¸¸åœ¨ç³»ç»Ÿå¼•å¯¼è£…å…¥æ—¶å¯åŠ¨ï¼Œä»…åœ¨ç³»ç»Ÿå…³é—­æ—¶ç»ˆæ­¢ æ²¡æœ‰æ§åˆ¶ç»ˆç«¯  å¦‚ä½•ç¼–å†™ #   umask(0) è°ƒç”¨forkï¼Œä½¿çˆ¶è¿›ç¨‹exit setsidåˆ›å»ºä¸€ä¸ªæ–°ä¼šè¯ å·¥ä½œç›®å½•æ”¹ä¸ºæ ¹ç›®å½• å…³é—­ä¸éœ€è¦çš„æ–‡ä»¶æè¿°ç¬¦ å…³é—­æ ‡å‡†è¾“å…¥è¾“å‡º  å®ä¾‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026#34;apue.h\u0026#34;#include \u0026lt;syslog.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;sys/resource.h\u0026gt; void deamonize(const char *cmd){ int i, fd0, fd1, fd2; pid_t pid; struct rlimit rl; struct sigaction sa; // Clear file creation umask  umask(0); // Get maximum number of file descriptors  if (getrlimit(RLIMIT_NOFILE, \u0026amp;rl) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t get file limt\u0026#34;, cmd); // Become a session leader to lose controlling TTY  if( (pid=fork()) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t get file limit\u0026#34;, cmd); else if (pid != 0) // Parent  exit(0); setsid(); // Ensure future opens won\u0026#39;t allocate controlling TTYs  sa.sa_handler = SIG_IGN; sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = 0; if (sigaction(SIGHUP, \u0026amp;sa, NULL) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t ignore SIGHUP\u0026#34;, cmd); if ((pid = fork()) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t fork\u0026#34;, cmd); else if (pid != 0) exit(0); // Change the cuurent working directory to the root so  // we won\u0026#39;t prevent file systems from being unmounted.  if (chdir(\u0026#34;/\u0026#34;) \u0026lt; 0) err_quit(\u0026#34;%s: can\u0026#39;t change directory to /\u0026#34;, cmd); // Close all the file descriptors  if(rl.rlim_max == RLIM_INFINITY) rl.rlim_max = 1024; for(i = 0;i \u0026lt;rl.lim_max;i++) close(i); // Attach file descriptors 0, 1, 2 to /dev/ull  fd0 = open(\u0026#34;/dev/null\u0026#34;, O_RDWR); fd1 = dup(0); fd2 = dup(0); // Initiallize the log file  openlog(cmd, LOG_CONS, LOG_DAEMON); if(fd0!=0 || fd1 != 1 || fd2 != 2){ syslog(LOG_ERR, \u0026#34;unexpected file descriptors %d %d %d\u0026#34;, fd0, fd1, fd2); exit(1); } }   ä¸‹é¢ä½¿ç”¨daemonizeå°†mainå‡½æ•°å˜ä¸ºå®ˆæŠ¤è¿›ç¨‹\n1 2 3 4 5  void daemonize(const char *cmd); int main(int argc, char **argv){ daemonize(\u0026#34;main\u0026#34;); sleep(110); }   æŸ¥çœ‹æ‰§è¡Œç»“æœ\n1 2 3 4  lcl@FX50JK:~/Documents/hub/learning-record/linux/daemon$ ps -efj | grep ./main lcl 23738 1542 23737 23737 0 17:13 ? 00:00:00 ./main lcl 23744 6959 23743 6959 0 17:14 pts/1 00:00:00 grep --color=auto ./main   ä¸ä¸€ä¸ªæ­£å¸¸éå®ˆæŠ¤è¿›ç¨‹main1å¯¹æ¯”\n1 2 3 4  lcl@FX50JK:~/Documents/hub/learning-record/linux/daemon$ ps -efj | grep ./main UID PID PPID PGID SID C STIME TTY TIME CMD lcl 24079 1542 24078 24078 0 18:17 ? 00:00:00 ./main lcl 24089 2166 24089 2166 0 18:18 pts/0 00:00:00 ./main1   å¯è§å®ˆæŠ¤è¿›ç¨‹æ²¡æœ‰ç»‘å®šç»ˆç«¯ï¼Œåœ¨å­¤å„¿è¿›ç¨‹ç»„ï¼Œä¸æ˜¯ä¼šè¯é¦–è¿›ç¨‹\n"},{"id":18,"href":"/post/thread3/","title":"çº¿ç¨‹åŒæ­¥2","section":"Posts","content":"çº¿ç¨‹åŒæ­¥2 #  æ—¶é—´é”\n1 2 3  #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;time.h\u0026gt; int pthread_mutex_timedlock(pthread_mutex_t * restrict mutex, const struct timespec *restrict tsptr);   æ„¿æ„ç­‰å¾…timespecæè¿°çš„æ—¶é—´ï¼Œè¾¾åˆ°æ—¶é—´è¿”å›é”™è¯¯ç ETIMEOUT ä¸€ä¸ªä¾‹å­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // APUE example11-13 // pthread_mutex_timedlock // lcl 20190325 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;time.h\u0026gt;  int main (void) { int err; struct timespec tout; struct tm *tmp; char buf[64]; pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_lock(\u0026amp;lock); printf(\u0026#34;the mutex now is locked\\n\u0026#34;); clock_gettime(CLOCK_REALTIME, \u0026amp;tout); tmp = localtime(\u0026amp;tout.tv_sec); strftime(buf, sizeof(buf), \u0026#34;%r\u0026#34;, tmp); printf(\u0026#34;current time is %s\\n\u0026#34;,buf); tout.tv_sec += 10; err = pthread_mutex_timedlock(\u0026amp;lock,\u0026amp;tout); clock_gettime(CLOCK_REALTIME, \u0026amp;tout); tmp = localtime(\u0026amp;tout.tv_sec); strftime(buf,sizeof(buf), \u0026#34;%r\u0026#34;, tmp); printf(\u0026#34;the time is now %s\\n\u0026#34;,buf); if(err == 0) printf(\u0026#34;mutex locked again!\\n\u0026#34;); else printf(\u0026#34;can\u0026#39;t lock mutex again:%s\\n\u0026#34;,strerror(err)); exit(0); }   è¿è¡Œç»“æœï¼š\n1 2 3 4  the mutex now is locked current time is 01:08:51 PM the time is now 01:09:01 PM can\u0026#39;t lock mutex again:Connection timed out   è¯»å†™é”ï¼Œä¸‰ç§çŠ¶æ€è¯»åŠ é”ã€å†™åŠ é”å’Œä¸åŠ é”\n1 2 3 4 5 6 7 8  #include \u0026lt;pthread.h\u0026gt;int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destory(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)   å¦‚ä¸Šï¼Œå‡½æ•°åå¯ä»¥å¾ˆå¥½çš„åæ˜ å‡½æ•°çš„åŠŸèƒ½ã€‚\n å†™é”é˜»å¡å…¶ä»–åŠ é” è¯»é”é˜»å¡å†™é”ä½†ä¸é˜»å¡è¯»é” å†™é”åœ¨é˜»å¡æ—¶ï¼Œä¸å†å“åº”å…¶ä»–è¯»é”è¯·æ±‚ã€‚ "},{"id":19,"href":"/post/thread4/","title":"çº¿ç¨‹åŒæ­¥3","section":"Posts","content":"çº¿ç¨‹åŒæ­¥3 #  ä½¿ç”¨æ¡ä»¶å˜é‡è¿›è¡Œçº¿ç¨‹åŒæ­¥\n1 2 3 4 5 6 7  #include \u0026lt;pthread.h\u0026gt;int pthread_cond_init(pthread_cond_t *restrict cond; const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // APUE example 11-15  // using mutex and cond  // lcl 20190326  //  #include \u0026#34;../myapue/h\u0026#34;  #include \u0026lt;pthread.h\u0026gt;  struct msg{ struct msg * m_next; /* ...*/ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_mag(void) { struct msg *mp; for(;;) { pthread_mutex_lock(\u0026amp;qlock); while(workq == NULL) pthread_cond_wait(\u0026amp;qready, \u0026amp;qlock); mp = workq; workq = mp -\u0026gt; m_next; phread_mutex_unlock(\u0026amp;qlock); /* noe process msg */ } } void enqueue_msg(struct msg *mp) { pthread_mutex_lock(\u0026amp;qlock); mp-\u0026gt;m_next = workq; workq = mp; pthread_mutex_unlock(\u0026amp;qlock); pthread_cond_signal(\u0026amp;qready); }   barrierï¼Œå±éšœ\n1 2 3 4 5  int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count); int pthrerd_barrier_destroy(pthread_barrier_t *barrier); int pthread_barrier_wait(pthread_barruer_t *barrier);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  /* APUE example 11-16 * using barrier * lcl 20190326 * */ #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt;  #define NTHR 8 #define NUMNUM 8000000L #define TNUM (NUMNUM/NTHR)  long nums[NUMNUM]; long snums[NUMNUM]; pthread_barrier_t b; //extern int qsort(void *, size_t, size_t, // int (*)(const void*, const void *));  int complong(const void *arg1, const void *arg2) { long l1 = *(long *)arg1; long l2 = *(long *)arg2; if (l1 == l2) return 0; else if (l1 \u0026lt;l2) return -1; else return 1; } void *thr_fn(void *arg) { long idx = (long)arg; qsort(\u0026amp;nums[idx], TNUM, sizeof(long), complong); pthread_barrier_wait(\u0026amp;b); return ((void*)0); } void merge() { long idx[NTHR]; long i,minidx, sidx, num; for (i = 0;i\u0026lt;NTHR; i++) idx[i] = i*TNUM; for (sidx = 0;sidx \u0026lt; NUMNUM; sidx++){ num = LONG_MAX; for (i = 0; i\u0026lt;NTHR; i++){ if( (idx[i] \u0026lt; (i+1)*TNUM) \u0026amp;\u0026amp; (nums[idx[i]] \u0026lt; num)){ num = nums[idx[i]]; minidx = i; } } snums[sidx] = nums[idx[minidx]]; idx[minidx]++; } } int main() { unsigned long i; struct timeval start,end; long long startusec, endusec; double elapsed; int err; pthread_t tid; // create the initial set of numbers to sort.  srandom(1); for(i=0; i\u0026lt;NUMNUM; i++) { nums[i] = random(); } // create 8 threads to sort the numbers  gettimeofday(\u0026amp;start,NULL); pthread_barrier_init(\u0026amp;b, NULL, NTHR+1); for (i=0; i\u0026lt;NTHR; i++) { err = pthread_create(\u0026amp;tid,NULL,thr_fn,(void *)(i*TNUM)); if(err!=0) printf(\u0026#34;can\u0026#39;t create thread\u0026#34;); } pthread_barrier_wait(\u0026amp;b); merge(); gettimeofday(\u0026amp;end,NULL); startusec = start.tv_sec * 1000000 + start.tv_usec; endusec = end.tv_sec * 1000000 + end.tv_usec; elapsed = (double)(endusec - startusec)/1000000.0; printf(\u0026#34;sort using %.4f seconds\\n\u0026#34;,elapsed); for(i=0;i\u0026lt;100;i++) printf(\u0026#34;%ld\\n\u0026#34;,snums[i]); exit(0); }   "},{"id":20,"href":"/post/thread2/","title":"çº¿ç¨‹åŒæ­¥1","section":"Posts","content":"çº¿ç¨‹åŒæ­¥1 #  äº’æ–¥é‡mutex\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;pthread,h\u0026gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); //å¯¹äº’æ–¥é‡åŠ é”ï¼Œå¦‚æœå·²ç»åŠ é”ï¼Œçº¿ç¨‹é˜»å¡ç›´è‡³è¢«è§£é” int pthread_mutex_trylock(pthread_mutex_t *mutex); //å¦‚æœå·²ç»åŠ é”ï¼Œä¸ä¼šé˜»å¡ï¼Œè€Œæ˜¯è¿”å›EBUSY int pthread_mutex_unlock(pthread_mutex_t *mutex);   ä¸‹é¢çš„ä¾‹å­æ¼”ç¤ºå¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œå¼•ç”¨è®¡æ•°ã€‚å¼•ç”¨è®¡æ•°æ˜¯å—äº’æ–¥é‡ä¿æŠ¤çš„ï¼Œæ¯å›holdå¯¹è±¡æ—¶ï¼ŒåŠ é”ï¼Œå¼•ç”¨è®¡æ•°åŠ ä¸€;releaseæ—¶ï¼Œè§£é”ï¼Œå¼•ç”¨è®¡æ•°å‡ä¸€ã€‚ä¾‹å¤–æƒ…å†µæ˜¯åœ¨åˆå§‹åŒ–æ—¶ï¼Œå¯¹è±¡åˆšè¢«åˆ›é€ ï¼Œä¸éœ€è¦åŠ é”ã€‚ä»¥åŠå¯¹è±¡æœ€åä¸€ä¸ªå¼•ç”¨é‡Šæ”¾æ—¶åŒæ—¶é‡Šæ”¾ç©ºé—´ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // APUE 11-10 // use mutex to protect data // lcl 20190324 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  struct foo { int f_count; pthread_mutex_t f_lock; int f_id; /* more stuff here */ }; struct foo* foo_alloc(int id) { struct foo * fp; if ((fp = malloc(sizeof(struct foo))) != NULL) { fp-\u0026gt;f_count = 1; fp-\u0026gt;f_id = id; if (pthread_mutex_init(\u0026amp;fp-\u0026gt;f_lock, NULL) != 0) { free(fp); return(NULL); } } return(fp); } void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } void foo_rele(struct foo * fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (--fp-\u0026gt;f_count == 0) { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_destory(\u0026amp;fp-\u0026gt;f_lock); free(fp); } else { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } }   é¿å…æ­»é”ï¼Œä½¿ç”¨ä¸¤ä¸ªäº’æ–¥é”æ—¶ï¼Œéœ€è¦æ“ä½œæ—¶æŒ‡å®šåŠ é”é¡ºåºï¼Œå¦åˆ™å¯èƒ½é€ æˆä¸¤ä¸ªèµ„æºç›¸äº’æŒæœ‰å¯¹æ–¹éœ€è¦çš„é”ï¼Œä¸€ç›´å¤„äºé˜»å¡çŠ¶æ€ã€‚ä¸‹ä¾‹ä¸­ï¼Œæ—¢æœ‰ä¿æŠ¤å¯¹è±¡çš„é”f_lockï¼Œä¹Ÿæœ‰å¯¹è±¡æ‰€åœ¨çš„å…¨å±€å“ˆå¸Œè¡¨çš„é”hashlockï¼Œå½“åŒæ—¶ä½¿ç”¨ä¸¤ä¸ªé”æ—¶ï¼Œæ¯æ¬¡æ“ä½œéƒ½æŒ‰ç…§å…ˆé”hashlockå†é”f_lockã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  // APUE 11-11 // use two mutex to protect struct and hash // lcl 20190324 // #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  #define NHASH 29 #define HASH(id) (((unsigned long)id)%NHASH)  struct foo *fh[NHASH]; pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER; struct foo { int f_count; pthread_mutex_t f_lock; int f_id; /* more stuff here */ struct foo *f_next; }; struct foo* foo_alloc(int id) { struct foo * fp; int idx; if ((fp = malloc(sizeof(struct foo))) != NULL) { fp-\u0026gt;f_count = 1; fp-\u0026gt;f_id = id; if (pthread_mutex_init(\u0026amp;fp-\u0026gt;f_lock, NULL) != 0) { free(fp); return(NULL); } idx = HASH(id); pthread_mutex_lock(\u0026amp;hashlock); fp-\u0026gt;f_next = fh[idx]; fh[idx] = fp; pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_unlock(\u0026amp;hashlock); /* ... */ pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } return(fp); } void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); } struct foo_find(int id) { struct foo *fp; pthread_mutex_lock(\u0026amp;hashlock); for (fp = fh[HASH(id)]; fp != NULL; fp = fp-\u0026gt;f_next){ if (fp-\u0026gt;f_id == id){ foo_hold(fp); break; } } pthread_mutex_unlock(\u0026amp;hashlock); return(fp); } void foo_rele(struct foo * fp) { struct foo *fp; int idx; pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (fp-\u0026gt;f_count == 1) { pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_lock(\u0026amp;hashlock); pthread_mutex_lock(\u0026amp;fp-\u0026gt;f_lock); if (fp-\u0026gt;f_count != 1) { fp-\u0026gt;f_count--; pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_unlock(\u0026amp;hashlock); return; } idx = HASH(fp-\u0026gt;f_id); tfp = fh[idx]; if(tfp == fp){ fh[idx] = fp -\u0026gt;f_next; } else { while(tfp-\u0026gt;next != fp) { tfp = tfp-\u0026gt;next; } tfp-\u0026gt;next = fp-\u0026gt;next; } pthread_mutex_unlock(\u0026amp;hashlock); pthread_mutex_unlock(\u0026amp;fp-\u0026gt;f_lock); pthread_mutex_destory(\u0026amp;fp-\u0026gt;f_lock); free(fp); } else { fp-\u0026gt;f_count--; pthread_mutex_unlock(fp-\u0026gt;f_lock); } }   è¿™æ ·åšçš„è´Ÿæ‹…æ˜¾è€Œæ˜“è§ï¼Œå°¤å…¶æ˜¯releaseæ—¶ï¼Œå› ä¸ºæœ€åä¸€ä¸ªå¼•ç”¨releaseæ—¶ï¼Œéœ€è¦åˆ é™¤ï¼Œåˆéœ€è¦æ“ä½œå“ˆå¸Œè¡¨ï¼ŒæŒ‰ç…§åŠ é”é¡ºåºçš„è¦æ±‚ï¼Œæ­¤æ—¶è¦å…ˆé‡Šæ”¾f_lockï¼Œå†é”hashlockï¼Œå†é”f_lockï¼Œè€Œå†è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½åˆå ç”¨äº†è¯¥èµ„æºï¼Œéœ€è¦é‡æ–°æ£€æŸ¥è®¡æ•°ã€‚ã€‚\nè‹¥åªä½¿ç”¨hashlockæ¥ç®¡ç†ï¼Œåˆ™ä¼šå˜å¾—ç®€å•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void foo_hold(struct foo *fp) { pthread_mutex_lock(\u0026amp;hashlock); fp-\u0026gt;f_count++; pthread_mutex_unlock(\u0026amp;hashlock); } void foo_rele(struct foo * fp) { pthread_mutex_lock(\u0026amp;hashlock); if (--fp-\u0026gt;f_count == 0) { pthread_mutex_unlock(\u0026amp;hashlock); pthread_mutex_destory(\u0026amp;hashlock); free(fp); } else { pthread_mutex_unlock(\u0026amp;hashlock); } }   ä½†æ˜¯è¿™æ ·çš„é”å¤ªç²—ï¼Œå®¹æ˜“é€ æˆå¤šä¸ªçº¿ç¨‹ç­‰å¾…åŒä¸€æŠŠé”ï¼Œå½±å“æ€§èƒ½ã€‚æ‰€ä»¥éœ€è¦è¿›è¡Œæ€§èƒ½å’Œå¤æ‚çš„å¹³è¡¡ã€‚\n"},{"id":21,"href":"/post/thread1/","title":"çº¿ç¨‹çš„åˆ›å»ºåŠé€€å‡º","section":"Posts","content":"çº¿ç¨‹çš„åˆ›å»ºåŠé€€å‡º #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  1 // APUE example 11-2 2 // lcl 20190314 3 4 #include \u0026#34;../myapue.h\u0026#34; 5 #include \u0026lt;pthread.h\u0026gt; 6 7 pthread_t ntid; 8 9 void printids(const char *s) 10 { 11 pid_t pid; 12 pthread_t tid; 13 14 pid = getpid(); 15 tid = pthread_self(); 16 printf(\u0026#34;%s pid %lu tid %lu (0x%lx)\\n\u0026#34;,s,(unsigned long)pid,(unsigned long)tid,(unsigned long)tid); 17 } 18 19 void * thr_fn(void *arg) 20 { 21 printids(\u0026#34;new thread: \u0026#34;); 22 return ((void*)0); 23 } 24 25 int main (void) 26 { 27 int err; 28 err = pthread_create(\u0026amp;ntid, NULL, thr_fn, NULL); 29 if (err != 0) 30 printf(\u0026#34;can\u0026#39;t create thread\\n\u0026#34;); 31 printids(\u0026#34;main thread: \u0026#34;); 32 sleep(1); 33 exit(0); 34 }   ç¼–è¯‘æ—¶éœ€è¦é“¾æ¥pthreadï¼Œå› ä¸ºpthreadä¸æ˜¯æ ‡å‡†åº“\n1 2 3 4  [root@f3c6f9f95723 ch11]# gcc pthr.c -lpthread -g -o pthr [root@f3c6f9f95723 ch11]# ./pthr main thread: pid 63 tid 140407368517440 (0x7fb323530740) new thread: pid 63 tid 140407360116480 (0x7fb322d2d700)   çº¿ç¨‹é€€å‡ºï¼Œæ¥æ”¶é€€å‡ºç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  1 // APUE example 11-2 2 // lcl 20190304 3 4 #include \u0026#34;../myapue.h\u0026#34; 5 #include \u0026lt;pthread.h\u0026gt; 6 7 void *thr_fn1(void *arg) 8 { 9 printf(\u0026#34;thread 1 returning\\n\u0026#34;); 10 return ((void *) 1); 11 } 12 13 void *thr_fn2(void *arg) 14 { 15 printf(\u0026#34;thread 2 exiting\\n\u0026#34;); 16 pthread_exit((void *)2); 17 } 18 19 int main(void) 20 { 21 int err; 22 pthread_t tid1,tid2; 23 void *tret; 24 25 err = pthread_create(\u0026amp;tid1, NULL, thr_fn1, NULL); 26 if(err != 0) 27 printf(\u0026#34;err %d, can\u0026#39;t create thread 1\\n\u0026#34;,err); 28 err = pthread_create(\u0026amp;tid2, NULL, thr_fn2, NULL); 29 if (err != 0) 30 printf(\u0026#34;err %d, can\u0026#39;t create thread 2\\n\u0026#34;,err); 31 err = pthread_join(tid1, \u0026amp;tret); 32 if (err != 0) 33 printf(\u0026#34;err %d, can\u0026#39;t join with thread1\\n\u0026#34;,err); 34 printf(\u0026#34;thread 1 exit code %ld\\n\u0026#34;,(long)tret); 35 err = pthread_join(tid2, \u0026amp;tret); 36 if (err != 0) 37 printf(\u0026#34;err %d, can\u0026#39;t join with thread2\\n\u0026#34;,err); 38 printf(\u0026#34;thread 2 exit code %ld\\n\u0026#34;,(long)tret); 39 exit(0); 40 }   1 2 3 4 5 6  [root@f3c6f9f95723 ch11]# gcc get_exit_of_thread.c -g -lpthread -o get_exit_of_thread [root@f3c6f9f95723 ch11]# ./get_exit_of_thread thread 1 returning thread 1 exit code 1 thread 2 exiting thread 2 exit code 2   çº¿ç¨‹é€€å‡ºæ—¶è¿”å›åœ°å€ï¼Œæ­¤åœ°å€åœ¨çº¿ç¨‹é€€å‡ºåè¢«è¦†ç›–çš„ä¾‹å­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  // APUE example 11-4 // lcl 20190314 /****************************************** [root@f3c6f9f95723 ch11]# ./exit_thread_err structure at 0x7f33a3ce7f00 foo.a = 1 foo.b = 2 foo.c = 3 foo.d = 4 parent create a second thread: thread 2: ID is 139859768280832 structure at 0x7ffebf271120 foo.a = -1546748160 foo.b = 32563 foo.c = -1087952529 foo.d = 32766 ******************************************/ #include \u0026#34;../myapue.h\u0026#34; #include \u0026lt;pthread.h\u0026gt;  struct foo { int a, b, c, d; }; void printfoo(const char *s, const struct foo *fp) { printf(\u0026#34;%\u0026#34;,s); printf(\u0026#34; structure at 0x%lx\\n\u0026#34;, (unsigned long)fp); printf(\u0026#34; foo.a = %d\\n\u0026#34;,fp-\u0026gt;a); printf(\u0026#34; foo.b = %d\\n\u0026#34;,fp-\u0026gt;b); printf(\u0026#34; foo.c = %d\\n\u0026#34;,fp-\u0026gt;c); printf(\u0026#34; foo.d = %d\\n\u0026#34;,fp-\u0026gt;d); } void *thr_fn1(void *arg) { struct foo foo1 = {1,2,3,4}; printfoo(\u0026#34;thread 1:\\n\u0026#34;, \u0026amp;foo1); pthread_exit((void*)\u0026amp;foo1); } void *thr_fn2(void *arg) { printf(\u0026#34;thread 2: ID is %lu\\n\u0026#34;,(unsigned long)pthread_self()); pthread_exit((void *)0); } int main(void) { int err; pthread_t tid1,tid2; struct foo *fp; err = pthread_create(\u0026amp;tid1, NULL, thr_fn1, NULL); if(err != 0) printf(\u0026#34;err %d, can\u0026#39;t create thread 1\\n\u0026#34;,err); err = pthread_join(tid1, (void*)fp); if (err != 0) printf(\u0026#34;err %d, can\u0026#39;t join with thread1\\n\u0026#34;,err); sleep(1); printf(\u0026#34;parent create a second thread:\\n\u0026#34;); err = pthread_create(\u0026amp;tid2, NULL, thr_fn2, NULL); if (err != 0) printf(\u0026#34;err %d, can\u0026#39;t create thread 2\\n\u0026#34;,err); sleep(1); printfoo(\u0026#34;parent:\\n\u0026#34;,fp); exit(0); }   "},{"id":22,"href":"/post/socket/","title":"socketç¼–ç¨‹","section":"Posts","content":"socketç¼–ç¨‹ #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXLINE 1024  int main(int argc, char **argv) { struct addrinfo *p,*listp, hints; char buf[MAXLINE]; int rc, flags; if(argc != 2){ fprintf(stderr,\u0026#34;usage: %s \u0026lt;domain niane\u0026gt;\\n\u0026#34;, argv[0]); exit(0); } //Get a list of addrinfo records  memset(\u0026amp;hints,0,sizeof(struct addrinfo)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; if((rc=getaddrinfo(argv[1],NULL,\u0026amp;hints,\u0026amp;listp))!=0){ //Get a list of addrinfo records  memset(\u0026amp;hints,0,sizeof(struct addrinfo)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; if((rc=getaddrinfo(argv[1],NULL,\u0026amp;hints,\u0026amp;listp))!=0){ fprintf(stderr, \u0026#34;getaddrinfo error: %s\\n\u0026#34;,gai_strerror(rc)); exit(1); } // Walk the list and display each IP address  flags = NI_NUMERICHOST; for(p=listp;p;p=p-\u0026gt;ai_next){ getnameinfo(p-\u0026gt;ai_addr,p-\u0026gt;ai_addrlen, buf, MAXLINE,NULL,0,flags); printf(\u0026#34;%s\\n\u0026#34;,buf); } freeaddrinfo(listp); exit(0); }   1 2 3 4 5  [root@f3c6f9f95723 inet]# ./hostinfo www.baidu.com 14.215.177.38 14.215.177.39 [root@f3c6f9f95723 inet]# ./hostinfo www.ustc.edu.cn 218.22.21.21   "},{"id":23,"href":"/post/lambda/","title":"lambdaè¡¨è¾¾å¼","section":"Posts","content":"lambdaè¡¨è¾¾å¼ #  ä»‹ç» #  ä¸€ä¸ªlambdaè¡¨è¾¾å¼è¡¨ç¤ºä¸€ä¸ªå¯è°ƒç”¨çš„ä»£ç å•å…ƒï¼Œå¯ä»¥å°†å…¶ç†è§£ä¸ºä¸€ä¸ªæœªå‘½åçš„å†…è”å‡½æ•°ã€‚å½¢å¼ä¸º\n1 2  [capture list](parameter list) -\u0026gt; return type { function body} //å¿…é¡»ä½¿ç”¨å°¾ç½®è¿”å›   å‡ ä¸ªç‰¹ç‚¹\n å¿…é¡»ä½¿ç”¨å°¾ç½®è¿”å› åœ¨åˆ›å»ºæ—¶æ•è· åªæœ‰ä¸€è¡Œreturnè¯­å¥æ—¶å¯çœç•¥è¿”å›ç±»å‹ï¼Œå¦åˆ™é»˜è®¤ä¸ºvoid ä¸€èˆ¬åœ¨ç»™ç®—æ³•ä¼ é€’è°“è¯æ—¶å¯ä»¥ä½¿ç”¨  lambdaè¡¨è¾¾å¼çš„æ•è· #   å€¼æ•è·  1 2 3 4 5 6 7  void fun1() { size_t v1 = 21; auto f = [v1]{return v1;}; //çœç•¥äº†å‚æ•°åˆ—è¡¨  v1 = 0; cout \u0026lt;\u0026lt; f(); }   è¾“å‡º21\n å¼•ç”¨æ•è·  1 2 3 4 5 6 7  void fun2() { size_t v2 = 21; auto f2 = [\u0026amp;v2] {return v2;}; v2 = 0; cout \u0026lt;\u0026lt; f2(); }   å°†è¾“å‡º0\n éšå¼æ•è· åªåœ¨æ•è·åˆ—è¡¨é‡ŒåŠ =ï¼ˆå€¼ï¼‰æˆ–è€…\u0026amp;ï¼ˆå¼•ç”¨ï¼‰ï¼Œç”±ç¼–è¯‘å™¨æ¥æ¨æ–­  1 2 3 4 5 6 7  void fun3() { size_t v3 = 21; auto f3 = [\u0026amp;] {return v3;}; v3 = 0; cout \u0026lt;\u0026lt; f3(); }   è¾“å‡º0\n æ··åˆæ•è· å³åœ¨æ•è·åˆ—è¡¨å¼€å§‹ä½¿ç”¨=æˆ–è€…\u0026amp;éšå¼æ•è·ï¼Œå†å¯¹ä¸åŒçš„æ•è·å˜é‡ä½¿ç”¨æ˜¾å¼æ•è·ã€‚æ­¤æ˜¾å¼æ•è·å¿…é¡»ä¸å¼€å§‹çš„éšå¼æ•è·ä¸åŒï¼ˆå€¼æˆ–å¼•ç”¨ï¼‰  mutable #  å¯¹äºå€¼æ•è·ï¼Œlambdaè¡¨è¾¾å¼ä¸èƒ½æ”¹å˜æ•è·çš„å‚æ•°ï¼Œå¦‚\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [=] (int i) {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   ç¼–è¯‘é”™è¯¯\n error: increment of read-only variable \u0026lsquo;v4\u0026rsquo;|\n å¯ä»¥åœ¨å‚æ•°åˆ—è¡¨åé¢åŠ mutableï¼ŒåŒæ—¶å³ä½¿æ²¡æœ‰å‚æ•°ï¼Œå‚æ•°åˆ—è¡¨ä¹Ÿä¸èƒ½çœç•¥äº†ã€‚\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [=] (int i) mutable {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   è€Œç”¨å¼•ç”¨æ•è·æ—¶å°±ä¸éœ€è¦äº†\n1 2 3 4 5 6  void fun4() { size_t v4 =21; auto f4 = [\u0026amp;] (int i) {return (++v4) + i;}; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f4(9); }   è¿”å› #  å½“å‡½æ•°ä½“ä¸æ˜¯åªæœ‰ä¸€æ¡returnè¯­å¥æ—¶éœ€è¦æŒ‡å®šè¿”å›ç±»å‹ï¼Œä¸”å¿…é¡»ç”¨å°¾ç½®è¿”å›ç±»å‹ã€‚\n"},{"id":24,"href":"/post/allocator/","title":"allocator","section":"Posts","content":"allocator #   #include \u0026lt;memory\u0026gt;\n  allocator\u0026lt;T\u0026gt; a å®šä¹‰ä¸€ä¸ªåä¸ºaçš„allocatorå¯¹è±¡ï¼Œå®ƒå¯ä»¥ä¸ºç±»å‹ä¸ºTçš„å¯¹è±¡åˆ†é…å†…å­˜\n  a.allocate(n) åˆ†é…ä¸€æ®µåŸå§‹çš„ã€æœªæ„é€ çš„å†…å­˜ï¼Œä¿å­˜nä¸ªç±»å‹ä¸ºTçš„å¯¹è±¡\n  a.deallocate(p,n) é‡Šæ”¾ä»T*æŒ‡é’ˆpä¸­åœ°å€å¼€å§‹çš„å†…å­˜ï¼Œè¿™å—å†…å­˜ä¿å­˜äº†nä¸ªç±»å‹ä¸ºTçš„å¯¹è±¡ï¼Œä¸a.allocate(n)å¯¹åº”\n  a.construct(p, args) pæ˜¯æŒ‡é’ˆï¼Œargsæ˜¯å¯¹è±¡çš„æ„é€ å‡½æ•°ï¼Œç”¨æ¥æ„é€ å¯¹è±¡\n  a.destroy(p) å¯¹pæŒ‡å‘çš„å¯¹è±¡æ‰§è¡Œææ„å‡½æ•°\n "},{"id":25,"href":"/post/bind/","title":"bind","section":"Posts","content":"bind #   auto g = bind(f, arg_list)\n ç”¨æˆ‘è‡ªå·±çš„è¯æ¥è¯´ï¼Œå°±æ˜¯æŠŠåŸæ¥å‡½æ•°fçš„å‚æ•°é‡æ–°å®‰æ’ï¼Œå¯ä»¥ç›´æ¥ç»‘å®šå€¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å ä½ç¬¦placeholderï¼Œè¾¾åˆ°å‡å°‘å‚æ•°æˆ–è€…è°ƒæ¢å‚æ•°é¡ºåºçš„ä½œç”¨ã€‚\nä¾‹å¦‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;functional\u0026gt; using namespace std; using namespace std::placeholders; // for _1, _2 ...  string f(string a1, string a2, string a3, string a4) { return a1+a2+a3+a4; } int main(int argc, char *argv[]) { auto g = bind(f,_1,\u0026#34;Two\u0026#34;,\u0026#34;Three\u0026#34;,\u0026#34;Four\u0026#34;); cout \u0026lt;\u0026lt; g(\u0026#34;One\u0026#34;) \u0026lt;\u0026lt; endl; return 0; }   è¾“å‡º\n OneTwoThreeFour\n è¿™æ ·å°±æŠŠä¸€ä¸ªå››ä¸ªå‚æ•°çš„å‡½æ•°f(4)è½¬æˆäº†ä¸€ä¸ªå‚æ•°çš„å‡½æ•°g(1)ï¼Œå…¶ä¸­çš„å ä½ç¬¦_1è¡¨ç¤ºgçš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚\nå¦‚æœäº¤æ¢å‚æ•°çš„é¡ºåºï¼Œä¹Ÿæ˜¯ä½¿ç”¨å ä½ç¬¦ï¼Œæ¯”å¦‚ä¸Šä¾‹\n1 2 3 4 5 6  int main(int argc, char *argv[]) { auto g = bind(f,_4,_2,_3,_1); cout \u0026lt;\u0026lt; g(\u0026#34;One\u0026#34;,\u0026#34;Two\u0026#34;,\u0026#34;Three\u0026#34;,\u0026#34;Four\u0026#34;) \u0026lt;\u0026lt; endl; return 0; }   è¾“å‡º\n FourTwoThreeOne\n æ‰€ä»¥å ä½ç¬¦å°±æ˜¯è¡¨ç¤ºgä¸­çš„ç¬¬å‡ ä¸ªå‚æ•°ï¼Œå†æŒ‰é¡ºåºä¼ ç»™fã€‚\nå¯ä»¥ç”¨äºè°ƒæ•´å‚æ•°é¡ºåºï¼Œç»‘å®šéƒ¨åˆ†å‚æ•°ç­‰ï¼Œåšä¸€ä¸ªå‡½æ•°é€‚é…å™¨çš„åŠŸèƒ½ã€‚\n"},{"id":26,"href":"/post/inserter/","title":"æ’å…¥è¿­ä»£å™¨","section":"Posts","content":"æ’å…¥è¿­ä»£å™¨ #  æ¥å—ä¸€ä¸ªå®¹å™¨ï¼Œç”Ÿæˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œå®ç°å‘ç»™å®šå®¹å™¨æ’å…¥å…ƒç´ \næ“ä½œ #   it = t\n åœ¨itæŒ‡å®šçš„å½“å‰ä½ç½®æ’å…¥å€¼tï¼Œä¸”æ ¹æ®æ’å…¥è¿­ä»£å™¨çš„ç±»å‹ä¸åŒï¼Œåˆ†åˆ«è°ƒç”¨c.push_back(t), c.oush_front(t), c.insert(t,p)\n *it, it++, ++it\n æœ‰è¿™äº›å½¢å¼ï¼Œä½†æ˜¯ä»€ä¹ˆéƒ½ä¸åš\n##ç±»å‹\n  back_inserter åˆ›å»ºä¸€ä¸ªä½¿ç”¨push_backçš„è¿­ä»£å™¨\n  front_inserter åˆ›å»ºä¸€ä¸ªä½¿ç”¨push_frontçš„è¿­ä»£å™¨\n  inserter åˆ›å»ºä¸€ä¸ªä½¿ç”¨insertçš„è¿­ä»£å™¨ è‹¥itæ˜¯ä¸€ä¸ªinserteråˆ™ä»¥ä¸‹ä»£ç \n  1  *it = val;   ä¸\n1 2  it = c.insert(it, val); ++it;   æ•ˆæœä¸€æ · ç¤ºä¾‹:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; void Output(const list\u0026lt;int\u0026gt; \u0026amp;a){ ostream_iterator\u0026lt;int\u0026gt; out_iter(cout,\u0026#34; \u0026#34;); copy(a.cbegin(),a.cend(),out_iter); cout \u0026lt;\u0026lt; endl; } int main(int argc, char *argv[]) { list\u0026lt;int\u0026gt;a1 = {1,2,3,4},a2,a3,a4; copy(a1.cbegin(),a1.cend(),inserter(a2,a2.begin())); copy(a1.cbegin(),a1.cend(),front_inserter(a3)); copy(a1.cbegin(),a1.cend(),back_inserter(a4)); Output(a2); Output(a3); Output(a4); }   è¾“å‡º\n 1 2 3 4 4 3 2 1 1 2 3 4\n"},{"id":27,"href":"/post/iostreamiterator/","title":"è¾“å…¥è¾“å‡ºæµè¿­ä»£å™¨","section":"Posts","content":"è¾“å…¥è¾“å‡ºæµè¿­ä»£å™¨ #  istream_iterator #   åˆ›å»ºä¸€ä¸ªistream_iteratorï¼Œç„¶åæŠŠå®ƒç»‘å®šåˆ°ä¸€ä¸ªæµ å¦‚æœé»˜è®¤åˆå§‹åŒ–ï¼Œåˆ™æ˜¯ä¸€ä¸ªå°¾åå€¼çš„è¿­ä»£å™¨  ostream_iterator #  1 2  ostream_iterator\u0026lt;T\u0026gt; out(os) //outå°†ç±»å‹ä¸ºTçš„å€¼å†™åˆ°osæµä¸­ ostream_iterator\u0026lt;T\u0026gt; out(os, d) //outå°†ç±»å‹ä¸ºTçš„å€¼å†™åˆ°osæµä¸­ï¼Œä¸”åœ¨åé¢åŠ ä¸Šå­—ç¬¦ä¸²d   æœ‰äº†è¾“å…¥è¾“å‡ºæµè¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¾“å…¥è¾“å‡ºæµå½“ä½œå®¹å™¨æ¥ä½¿ç”¨ï¼Œåœ¨æ‹·è´ï¼Œåˆå§‹åŒ–ç­‰ç­‰æœ‰å’Œå®¹å™¨æ“ä½œç›¸åŒçš„å½¢å¼ï¼Œä»£ç æ¯”è¾ƒå¥½çœ‹\nä¾‹å­\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; int main(int argc, char* argv[]) { istream_iterator\u0026lt;int\u0026gt; in_iter(cin); istream_iterator\u0026lt;int\u0026gt; int_eof; vector\u0026lt;int\u0026gt; vec(in_iter,int_eof); //[1]  ostream_iterator\u0026lt;int\u0026gt; out_iter(cout,\u0026#34; \u0026#34;); copy(vec.cbegin(),vec.cend(),out_iter); //[2] }   è¯¥æ®µä»£ç æ¥å—å±å¹•è¾“å…¥ï¼Œç„¶åè¾“å‡ºåˆ°å±å¹•ï¼Œç„¶å[1]å’Œ[2]éƒ½æ˜¯å®¹å™¨ä½¿ç”¨è¿­ä»£å™¨çš„æ“ä½œã€‚æ¯”æˆ‘ä»¬ç›´æ¥å†™å¾ªç¯æ˜¾å¾—ç®€æ´ã€‚\n"},{"id":28,"href":"/post/codewar1/","title":"codewar é¢˜1","section":"Posts","content":"å¤§æ•°ï¼Œé˜¶ä¹˜ï¼Œå°æ•°ä½æ•° #  åœ¨codewarçš„ä¸€é“é¢˜\n Consider the following numbers (where n! is factorial(n)):\nu1 = (1 / 1!) * (1!) u2 = (1 / 2!) * (1! + 2!) u3 = (1 / 3!) * (1! + 2! + 3!) un = (1 / n!) * (1! + 2! + 3! + \u0026hellip; + n!) Which will win: 1 / n! or (1! + 2! + 3! + \u0026hellip; + n!)?\nAre these numbers going to 0 because of 1/n! or to infinity due to the sum of factorials or to another number?\nTask\nCalculate (1 / n!) * (1! + 2! + 3! + \u0026hellip; + n!) for a given n, where n is an integer greater or equal to 1.\nTo avoid discussions about rounding, return the result truncated to 6 decimal places, for example:\n1.0000989217538616 will be truncated to 1.000098\n1.2125000000000001 will be truncated to 1.2125\nRemark\nKeep in mind that factorials grow rather rapidly, and you need to handle large inputs.\n ä¸€å¼€å§‹æäº¤ï¼Œè¿ç®€å•çš„æµ‹è¯•çš„éƒ½è¿‡ä¸äº†ï¼Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Suite { public: static double going(int n); }; long long f(int n){ if(n==1) return 1; else return (long long)(n*f(n-1)); } long long fa(int n){ if(n==1) return f(1); else return (long long)(f(n)+fa(n-1)); } double Suite::going(int n){ return result=((double)1.0)/f(n)*fa(n); }   ç»™å‡ºè¿™æ ·çš„ç»“æœ\n Test Results:\ngoing_Tests\nFixed__Tests\nExpected: equal to 1.2125\nActual: 1.2125\n åŸå› æ˜¯æµ®ç‚¹æ•°ä¸èƒ½ç›´æ¥æ¯”è¾ƒï¼Œå› æ­¤åšäº†å¦‚ä¸‹æ”¹è¿›ï¼š\n1 2 3 4 5 6  double Suite::going(int n){ double result = ((double)1.0)/f(n)*fa(n); long long re_l = (long long)(result*1000000); result = ((double)re_l)/1000000.0; return result; }   ç°åœ¨çš„æµ‹è¯•ç»“æœ\n Test Results:\ngoing_Tests\nFixed__Tests\nLog\nCorrect. Testing; Expected is 1.275, and got 1.275\nCorrect. Testing; Expected is 1.2125, and got 1.2125\nCorrect. Testing; Expected is 1.173214, and got 1.173214\nCorrect. Testing; Expected is 1.146651, and got 1.146651\nCorrect. Testing; Expected is 1.052786, and got 1.052786\nTesting; Expected should be 1.034525, but got 0.68527\nExpected: false\nActual: 1\nRandom_tests\nLog\n****************** Random Tests **** going\nTesting; Expected should be 1.032292, but got 1.166542\nExpected: false\nActual: 1\n å¾ˆæ˜æ˜¾æ˜¯é˜¶ä¹˜ç»“æœå¤ªå¤§ï¼Œè¶…å‡ºäº†long longçš„ç•Œé™ã€‚\n20190401æ›´ï¼š åŸæœ¬æƒ³ç€ä½¿ç”¨å¤§æ•°çš„å¤„ç†æ–¹æ³•ï¼Œå¦‚https://blog.csdn.net/qq_39445165/article/details/88377252\nä½†æ˜¯å‘ç°å³ä½¿ä½¿ç”¨äº†æ•°ç»„è¡¨ç¤ºå¾ˆå¤§çš„æ•°ï¼Œåé¢çš„ä¹Ÿä¸å¥½å¤„ç†ã€‚ ç°åœ¨æŠŠå¼å­è½¬åŒ–æˆ1+1/n+1/n(n-1)+\u0026hellip;+1/n(n-1)\u0026hellip;2+1/n!ï¼Œè‹¥åˆ†æ¯å¾ˆå¤§æ¯”å¦‚å¤§äº10çš„8æ¬¡æ–¹ï¼Œé‚£ä¹ˆè¿™ä¸€é¡¹å¯¹äºå’Œæ²¡æœ‰æ„ä¹‰ï¼Œå› ä¸ºç²¾åº¦é™åˆ¶åœ¨å…­ä½å°æ•°ï¼Œäºæ˜¯æ–°çš„å¤„ç†æ–¹æ³•\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Suite { public: static double going(int n); }; double Suite::going(int n){ int i; long long re_l,temp = n; double result = 1.0; for(i=1;i\u0026lt;n;i++) { result += ((double)1.0)/temp; temp *= (n-i); if(temp\u0026gt;100000000) break; } re_l = (long long)(result*1000000); result = ((double)re_l)/1000000.0; return result; }   é€šè¿‡äº†æµ‹è¯•\n"},{"id":29,"href":"/post/codewar2/","title":"CodeWar é¢˜2","section":"Posts","content":"CodeWar::DoubleCola #  CodeWarä¸Šçš„ä¸€é“é¢˜\n Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a \u0026ldquo;Double Cola\u0026rdquo; drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on.\nFor example, Penny drinks the third can of cola and the queue will look like this:\n Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny\n Write a program that will return the name of the person who will drink the n-th cola.\n è¿™ç§å‰ç«¯åˆ é™¤ï¼ŒdoubleååŠ å…¥åé¢ï¼Œè‡ªç„¶æƒ³åˆ°åŒå‘é˜Ÿåˆ—dequeæ¥åš\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;deque\u0026gt;using namespace std; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { deque\u0026lt;string\u0026gt; q; string tmp; long long i; for(i=0;i\u0026lt;names.size();i++) q.push_back(names[i]); for(i=1;i\u0026lt;r;i++) { tmp = q[0]; q.pop_front(); q.push_back(tmp); q.push_back(tmp); } return q[0]; }   ç®€å•çš„æµ‹è¯•èƒ½é€šè¿‡ï¼Œä½†æ˜¯æœ€ç»ˆæµ‹è¯•æ˜¾ç¤ºè¶…æ—¶ï¼Œæœç„¶ç›´æ¥æ“ä½œé˜Ÿåˆ—å¤ªæ…¢äº†ï¼Œå°¤å…¶ç»™çš„inputèŒƒå›´\n 1â€‰â‰¤ n â‰¤ 10000000000\n æ‰€ä»¥è¿˜éœ€è¦æ‰¾åˆ°é«˜æ•ˆçš„æ–¹æ³•ï¼Œ è€ƒè™‘æ•´ä¸ªå¾ªç¯ï¼Œäººæ•°æ¯è½®ç»“æŸåä¸º{5ï¼Œ10ï¼Œ20ï¼Œ40ï¼Œã€‚ã€‚ã€‚}ï¼Œé™¤ä»¥äººæ•°5ä¹‹åå°±æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶æ•°{1,2,4,8,\u0026hellip;}ï¼Œæ¯ä¸€è½®ç»“æŸæ—¶çš„åºå·ä¸º{1,3,15,\u0026hellip;.}ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­è½®æ¬¡ã€‚å¦å¤–æ¯ä¸€è½®æ‰€å¤„ä½ç½®ä¹Ÿå¯ä»¥é€šè¿‡å³ç§»å¾—åˆ°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { r--; long long n = r/names.size(); long long d; long long i = 64; while(i\u0026gt;0){ i--; if(((n+1)\u0026amp;((long long)1\u0026lt;\u0026lt;i))\u0026gt;\u0026gt;i == 1) break; } d = r - (((long long)1\u0026lt;\u0026lt;i) - 1)*names.size(); return names[d\u0026gt;\u0026gt;i]; }   æäº¤ç»“æœåçœ‹åˆ°çš„ä¼˜ç§€è§£ç­”ï¼š\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt; std::string who_is_next(std::vector\u0026lt;std::string\u0026gt; names, long long r) { long long x = r; while (x \u0026gt; names.size()) { x = (x - names.size() + 1) / 2; } return names[x-1]; }   "},{"id":30,"href":"/post/codewar3/","title":"codewar é¢˜3","section":"Posts","content":"CodeWar::Intervals #   Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.\nIntervals\nIntervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.\nOverlapping Intervals\nList containing overlapping intervals:\n [ [1,4], [7, 10], [3, 5] ]\n The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.\nExamples:\n sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9\n  sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7\n  sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19\n  æˆ‘çš„æ€è·¯æ˜¯\n åˆ›å»ºä¸€ä¸ªlimitså®¹å™¨å­˜å‚¨pair å¯¹è¾“å…¥æ¯ä¸€æ¡pairæ£€æŸ¥æ˜¯å¦ä¸limitsé‡Œçš„pairæœ‰é‡å çš„åœ°æ–¹ï¼Œå¦‚æœæœ‰ï¼Œè®°å½•ä¸‹ä½ç½®å­˜å…¥overlap å°†limitsé‡Œå¯¹åº”çš„æ¡ç›®åˆ å»ï¼Œåœ¨é‡åˆçš„æ¡ç›®ä¸­å¯»æ‰¾æœ€å°çš„ä¸‹é™å’Œæœ€å¤§çš„ä¸Šé™ï¼Œæ’å…¥limitsä¸­ æœ€åè®¡ç®—intervals  æˆ‘åœ¨è‡ªå·±çš„ideä¸­è¿è¡Œæ­£å¸¸ï¼Œä½†æ˜¯åœ¨codewarsæäº¤ä¹‹ååœ¨æŸäº›æƒ…å†µä¸‹å‡ºé”™ï¼Œcode139ï¼Œæ˜¯è¶Šç•Œä¹‹ç±»çš„é—®é¢˜ã€‚ ä¸€å¼€å§‹æˆ‘æ˜¯ç”¨vectoræ¥å­˜å‚¨limitsçš„ï¼Œç”±äºæ¶‰åŠåˆ°åˆ é™¤å…ƒç´ çš„é—®é¢˜ï¼Œç‰¹æ„è¿˜ç”¨overlapæ¥è®°å½•è¿­ä»£å™¨ï¼Œå¾ªç¯ä¹‹åä¸€èµ·åˆ é™¤ï¼Œç»è¿‡æ’é™¤è¿˜æ˜¯å‘ç°åˆ é™¤å…ƒç´ åè¿­ä»£å™¨å¤±æ•ˆçš„é—®é¢˜ï¼Œå¦‚ä¸Šç¬¬3æ­¥ã€‚äºæ˜¯æ”¹ç”¨listã€‚ è¿™æ¬¡çš„ç»å†æ›´æ·±åˆ»çš„å‘Šè¯‰æˆ‘è¦æ³¨æ„è¿­ä»£å™¨å¤±æ•ˆçš„é—®é¢˜ã€‚\nå…·ä½“ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; limits,tmp; int tmpmin,tmpmax,res=0; vector\u0026lt;list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;::iterator\u0026gt; overlap; if(intervals.size() == 0) return 0; for(auto interval : intervals){ overlap.clear(); tmp.clear(); for(auto it = limits.begin();it!=limits.end();it++){ if((interval.first\u0026gt;=(*it).first \u0026amp;\u0026amp; interval.first\u0026lt;(*it).second) || (interval.second\u0026gt;(*it).first \u0026amp;\u0026amp; interval.second\u0026lt;=(*it).second) || (interval.first\u0026lt;=(*it).first \u0026amp;\u0026amp; interval.second\u0026gt;=(*it).second)){ overlap.push_back(it); tmp.push_back(*it); } } tmp.push_back(interval); if(overlap.size()!=0){ for(auto del_it : overlap) {limits.erase(del_it);} tmpmin=(*tmp.begin()).first; tmpmax=(*tmp.begin()).second; for(auto tmp_it = tmp.begin();tmp_it!=tmp.end();tmp_it++){ if(tmpmin\u0026gt;(*tmp_it).first) tmpmin = (*tmp_it).first; if(tmpmax\u0026lt;(*tmp_it).second) tmpmax =(*tmp_it).second; } limits.push_back(make_pair(tmpmin,tmpmax)); } else limits.push_back(interval); } for (auto limit:limits){ res+=(limit.second-limit.first); } return res; }   Â·æäº¤ä¹‹åï¼Œæ¬£èµä¸€ä¸‹å…¶ä»–äººçš„è§£ç­”ï¼š\n ä½¿ç”¨äº†setçš„æ— é‡å¤æ€§ï¼Œç»Ÿè®¡åŒºé—´å†…çš„æ‰€æœ‰æ•´æ•°ï¼Œæœ€åè¿”å›setçš„sizeã€‚å¦‚æœæ•°çš„èŒƒå›´å¤§çš„è¯ï¼Œæµªè´¹å†…å­˜ï¼Œå°†ä¸¤ä¸ªæ•°è¡¨ç¤ºçš„åŒºé—´ï¼Œç”Ÿæˆäº†éå¸¸å¤šå…ƒç´ çš„setã€‚  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;unordered_set\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { std::unordered_set\u0026lt;int\u0026gt; ints; for (auto interv = intervals.begin(); interv != intervals.end(); ++interv){ for (int i = interv-\u0026gt;first; i \u0026lt; interv-\u0026gt;second; i++){ ints.insert(i); } } return ints.size(); }   å…ˆè¿›è¡Œäº†æ’åºï¼Œå†ç»´æŠ¤ä¸€ä¸ªmax_rightã€‚å³å¯è®¡ç®—ç»“æœã€‚è¿™ä¸ªç­”æ¡ˆæ¯”è¾ƒå¥½ã€‚  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;vector\u0026gt;#include \u0026lt;utility\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; interavls) { sort(interavls.begin(), interavls.end()); int ret = 0; int max_right = interavls[0].first; for (auto \u0026amp;i : interavls) if (i.second \u0026gt;= max_right) { ret += i.second - std::max(max_right, i.first); max_right = i.second; } return ret; }   "},{"id":31,"href":"/post/codewar/","title":"CodeWars","section":"Posts","content":"codewars #  æ„Ÿè§‰é¢˜æ¯”leetcodeçš„æœ‰è¶£ï¼Œé‚€è¯·é“¾æ¥ www.codewars.com/r/zuBfBg\n"},{"id":32,"href":"/post/hello-world/","title":"Hello World","section":"Posts","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start #  Create a new post #  1  $ hexo new \u0026#34;My New Post\u0026#34;   More info: Writing\nRun server #  1  $ hexo server   More info: Server\nGenerate static files #  1  $ hexo generate   More info: Generating\nDeploy to remote sites #  1  $ hexo deploy   More info: Deployment\n"}]